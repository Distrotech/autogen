\input texinfo
@c %**start of header
@setfilename autogen.info
@settitle AutoGen
@setchapternewpage off
@c %**end of header

@ignore
EDIT THIS FILE WITH CAUTION  (autogen.texi)

It has been AutoGen-ed  Friday September 21, 2001 at 12:57:16 PM PDT
From the definitions    stdin
and the template file   auto_gen

@end titlepage
@ignore
START == MAIN == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ifinfo
@node Top, Introduction, , (dir)
@top The Automated Program Generator
@comment  node-name,  next,  previous,  up

This file documents AutoGen, a tool designed for generating program
files that contain repetitive text with varied substitutions.
This document is very long because it is intended as a reference
document.  For a quick start example, @xref{Example Usage}.
For a simple example of Automated Option processing, @xref{Quick Start}.
For a full list of the Automated Option features, @xref{Features}.

This edition documents version @value{VERSION}, @value{UPDATED}.

@menu
* Introduction::         AutoGen's Purpose
* Definitions File::     AutoGen Definitions File
* Template File::        AutoGen Template
* Augmenting AutoGen::   Augmenting AutoGen
* autogen Invocation::   Invoking AutoGen
* Installation::         What Gets Installed Where
* AutoOpts::             Automated Option Processing
* Add-Ons::              Add-on packages for AutoGen
* Future::               Some ideas for the future.
* Concept Index::        General index
* Function Index::       Function index
@end menu

@end ifinfo

@ignore
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
@end ignore
@page
@node Introduction
@chapter Introduction
@cindex Introduction

AutoGen is a tool designed for generating program files that contain
repetitive text with varied substitutions.  Its goal is to simplify the
maintenance of programs that contain large amounts of repetitious text.
This is especially valuable if there are several blocks of such text
that must be kept synchronized.

One common example is the problem of maintaining the code required for
processing program options.  Processing options requires a minimum of
four different constructs be kept in proper order in different places in
your program.  You need at least:

@enumerate
@item
The flag character in the flag string,
@item
code to process the flag when it is encountered,
@item
a global state variable or two, and
@item
a line in the usage text.
@end enumerate

@noindent
You will need more things besides this if you choose to implement long
option names, rc/ini file processing, environment variables and so on.
All of this can be done mechanically; with the proper templates and this
program.  In fact, it has already been done and AutoGen itself uses it@:
@xref{AutoOpts}.  For a simple example of Automated Option processing,
@xref{Quick Start}.  For a full list of the Automated Option features,
@xref{Features}.

@menu
* Generalities::         The Purpose of AutoGen
* Example Usage::        A Simple Example
* csh/zsh caveat::       csh/zsh caveat
* Testimonial::          A User's Perspective
@end menu

@node Generalities
@section The Purpose of AutoGen

The idea of this program is to have a text file, a template if
you will, that contains the general text of the desired output file.
That file includes substitution expressions and sections of text that are
replicated under the control of separate definition files.

@cindex design goals

AutoGen was designed with the following features:

@enumerate
@item
The definitions are completely separate from the template.  By completely
isolating the definitions from the template it greatly increases the
flexibility of the template implementation.  A secondary goal is that a
template user only needs to specify those data that are necessary to describe
his application of a template.

@item
Each datum in the definitions is named.  Thus, the definitions can be
rearranged, augmented and become obsolete without it being necessary to
go back and clean up older definition files.  Reduce incompatibilities!

@item
Multiple values for a given name create an array of values.  These arrays of
values are used to control the replication of sections of the template.

@item
There are named collections of definitions.  They form a nested hierarchy.
Associated values are collected and associated with a group name.
These associated data are used collectively in sets of substitutions.

@item
The template has special markers to indicate where substitutions are
required, much like the @code{$@{VAR@}} construct in a shell @code{here
doc}.  These markers are not fixed strings.  They are specified at the
start of each template.  Template designers know best what fits into their
syntax and can avoid marker conflicts.

We did this because it is burdensome and difficult to avoid conflicts
using either M4 tokenizaion or C preprocessor substitution rules.  It
also makes it easier to specify expressions that transform the value.
Of course, our expressions are less cryptic than the shell methods.

@item
These same markers are used, in conjunction with enclosed keywords, to
indicate sections of text that are to be skipped and for sections of
text that are to be repeated.  This is a major improvement over using C
preprocessing macros.  With the C preprocessor, you have no way of
selecting output text because it is an @i{un}varying, mechanical
substitution process.

@item
Finally, we supply methods for carefully controlling the output.
Sometimes, it is just simply easier and clearer to compute some text or
a value in one context when its application needs to be later.  So,
functions are available for saving text or values for later use.
@end enumerate

@node Example Usage
@section A Simple Example
@cindex example, simple
@cindex simple example

This is just one simple example that shows a few basic features.
If you are interested, you also may run "make check" with the
@code{VERBOSE} enviornment variable set and see a number of other
examples in the @file{agen5/test/testdir} directory.

Assume you have an enumeration of names and you wish to associate some
string with each name.  Assume also, for the sake of this example,
that it is either too complex or too large to maintain easily by hand.
We will start by writing an abbreviated version of what the result
is supposed to be.  We will use that to construct our output templates.

@noindent
In a header file, @file{list.h}, you define the enumeration
and the global array containing the associated strings:

@example
typedef enum @{
        IDX_ALPHA,
        IDX_BETA,
        IDX_OMEGA @}  list_enum;

extern const char* az_name_list[ 3 ];
@end example

@noindent
Then you also have @file{list.c} that defines the actual
strings:

@example
#include "list.h"
const char* az_name_list[] = @{
        "some alpha stuff",
        "more beta stuff",
        "final omega stuff" @};
@end example

@noindent
First, we will define the information that is unique for
each enumeration name/string pair.

@example
autogen definitions list;
list = @{ list_element = alpha;
         list_info    = "some alpha stuff"; @};
list = @{ list_info    = "more beta stuff";
         list_element = beta; @};
list = @{ list_element = omega;
         list_info    = "final omega stuff"; @};
@end example

The @code{autogen definitions list;} entry defines the file as an
AutoGen definition file that uses a template named @code{list}.  That is
followed by three @code{list} entries that define the associations
between the enumeration names and the strings.  The order of the
differently named elements inside of list is unimportant.  They are
reversed inside of the @code{beta} entry and the output is unaffected.

Now, to actually create the output, we need a template or two that can
be expanded into the files you want.  In this program, we use a single
template that is capable of multiple output files.

It looks something like this.
(For a full description, @xref{Template File}.)

@example
[+ AutoGen5 template h c +]
[+ CASE (suffix) +][+
   ==  h  +]
typedef enum @{[+
   FOR list "," +]
        IDX_[+ (string-upcase! (get "list_element")) +][+
   ENDFOR list +] @}  list_enum;

extern const char* az_name_list[ [+ (count "list") +] ];
[+

   ==  c  +]
#include "list.h"
const char* az_name_list[] = @{[+
  FOR list "," +]
        "[+list_info+]"[+
  ENDFOR list +] @};[+

ESAC +]
@end example

The @code{[+ AutoGen5 template h c +]} text tells AutoGen that this is
an AutoGen version 5 template file; that it is to be processed twice;
that the start macro marker is @code{[+}; and the end marker is
@code{+]}.  The template will be processed first with a suffix value of
@code{h} and then with @code{c}.  Normally, the suffix values are
appended to the @file{base-name} to create the output file name.

The @code{[+ == h +]} and @code{[+ == c +]} @code{CASE} selection clauses
select different text for the two different passes.  In this example,
the output is nearly disjoint and could have been put in two separate
templates.  However, sometimes there are common sections and this is
just an example.

The @code{[+FOR list "," +]} and @code{[+ ENDFOR list +]} clauses delimit
a block of text that will be repeated for every definition of @code{list}.
Inside of that block, the definition name-value pairs that
are members of each @code{list} are available for substitutions.

The remainder of the macros are expressions.  Some of these contain
special expression functions that are dependent on AutoGen named values;
others are simply Scheme expressions, the result of which will be
inserted into the output text.  Other expressions are names of AutoGen
values.  These values will be inserted into the output text.  For example,
@code{[+list_info+]} will result in the value associated with
the name @code{list_info} being inserted between the double quotes and
@code{(string-upcase! (get "list_element"))} will first "get" the value
associated with the name @code{list_element}, then change the case of
all the letters to upper case.  The result will be inserted into the
output document.

If you have compiled AutoGen, you can copy out the template and
definitions, run @file{autogen} and produce exactly the hypothesized
desired output.

One more point, too.  Lets say you decided it was too much trouble to figure
out how to use AutoGen, so you created this enumeration and string list with
thousands of entries.  Now, requirements have changed and it has become
necessary to map a string containing the enumeration name into the enumeration
number.  With AutoGen, you just alter the template to emit the table of names.
It will be guaranteed to be in the correct order, missing none of the entries.
If you want to do that by hand, well, good luck.

@node csh/zsh caveat
@section csh/zsh caveat

AutoGen tries to use your normal shell so that you can supply shell code
in a manner you are accustomed to using.  If, however, you use csh or
zsh, you cannot do this.  Csh is sufficiently difficult to program that
it is unsupported.  Zsh, though largely programmable, also has some
anomolies that make it incompatible with AutoGen usage.  Therefore, when
invoking AutoGen from these environments, you must be certain to set the
SHELL environment variable to a Bourne-derived shell.  e.g., sh, ksh or
bash.

Any shell you choose for your own scripts need to follow these basic
requirements:

@enumerate
@item
It handles @code{trap $sig ":"} without output to standard out.
This is done when the server shell is first started.
If your shell does not handle this, then it may be able to by
loading functions from its start up files.
@item
At the beginning of each scriptlet, the command @code{\\cd $PWD}
is inserted.  This ensures that @code{cd} is not aliased to something
peculiar and each scriptlet starts life in the execution directory.
@item
At the end of each scriptlet, the command @code{echo mumble} is
appended.  The program you use as a shell must emit the single
argument @code{mumble} on a line by itself.
@end enumerate

@page
@node Testimonial
@section A User's Perspective

@format
Alexandre wrote:
>
> I'd appreciate opinions from others about advantages/disadvantages of
> each of these macro packages.
@end format

I am using AutoGen in my pet project, and find one of its best points to
be that it separates the operational data from the implementation.

Indulge me for a few paragraphs, and all will be revealed:
In the manual, Bruce cites the example of maintaining command line flags
inside the source code; traditionally spreading usage information, flag
names, letters and processing across several functions (if not files).
Investing the time in writing a sort of boiler plate (a template in
AutoGen terminology) pays by moving all of the option details (usage,
flags names etc.) into a well structured table (a definition file if you
will),  so that adding a new command line option becomes a simple matter
of adding a set of details to the table.

So far so good!  Of course, now that there is a template, writing all of
that tedious optargs processing and usage functions is no longer an
issue.  Creating a table of the options needed for the new project and
running AutoGen generates all of the option processing code in C
automatically from just the tabular data.  AutoGen in fact already ships
with such a template... AutoOpts.

One final consequence of the good separation in the design of AutoGen is
that it is retargetable to a greater extent.  The
egcs/gcc/fixinc/inclhack.def can equally be used (with different
templates) to create a shell script (inclhack.sh) or a c program
(fixincl.c).

This is just the tip of the iceberg.  AutoGen is far more powerful than
these examples might indicate, and has many other varied uses.  I am
certain Bruce or I could supply you with many and varied examples, and I
would heartily recommend that you try it for your project and see for
yourself how it compares to m4.
@cindex m4

As an aside, I would be interested to see whether someone might be
persuaded to rationalise autoconf with AutoGen in place of m4...  Ben,
are you listening?  autoconf-3.0! `kay?  =)O|

@format
Sincerely,
        Gary V. Vaughan
@end format

@ignore
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
@end ignore
@page
@node Definitions File
@chapter AutoGen Definitions File
@cindex definitions file
@cindex .def file

This chapter describes the syntax and semantics of the AutoGen
definition file.  In order to instantiate a template, you normally must
provide a definitions file that identifies itself and contains some
value definitions.  Consequently, we keep it very simple.  For
"advanced" users, there are preprocessing directives and comments that
may be used as well.

The definitions file is used to associate values with names.  When
multiple values are associated with a single name, an implicit array of
values is formed.  Values may be either simple strings or compound
collections of name-value pairs.  An array may not contain both simple
and compound members.  Fundamentally, it is as simple as:

@example
prog_name = "autogen";
flag = @{
    name      = templ_dirs;
    value     = L;
    descrip   = "Template search directory list";
@};
@end example

For purposes of commenting and controlling the processing of the
definitions, C-style comments and most C preprocessing directives are
honored.  The major exception is that the @code{#if} directive is
ignored, along with all following text through the matching
@code{#endif} directive.  The C preprocessor is not actually invoked, so
C macro substitution is @strong{not} performed.

@menu
* Identification::  The Identification Definition
* Definitions::     Named Definitions
* Dynamic Text::    Dynamic Text
* Directives::      Controlling What Gets Processed
* Predefines::      Pre-defined Names
* Comments::        Commenting Your Definitions
* Example::         What it all looks like.
* Full Syntax::     YACC Language Grammar
* Definition-less::  AutoGen without Definitions
@end menu

@node Identification
@section The Identification Definition
@cindex identification

The first definition in this file is used to identify it as a
AutoGen file.  It consists of the two keywords,
@samp{autogen} and @samp{definitions} followed by the default
template name and a terminating semi-colon (@code{;}).  That is:

@example
        AutoGen Definitions @var{template-name};
@end example

@noindent
Note that, other than the name @var{template-name}, the words
@samp{AutoGen} and @samp{Definitions} are searched for without case
sensitivity.  Most lookups in this program are case insensitive.

@noindent
Also, if the input contains more identification definitions,
they will be ignored.  This is done so that you may include
(@pxref{Directives}) other definition files without an identification
conflict.

@cindex template, file name
@cindex .tpl, file name
@cindex tpl, file name

@noindent
AutoGen uses the name of the template to find the corresponding template
file.  It searches for the file in the following way, stopping when
it finds the file:

@enumerate
@item
It tries to open @file{./@var{template-name}}.  If it fails,
@item
it tries @file{./@var{template-name}.tpl}.
@item
It searches for either of these files in the directories listed in the
templ-dirs command line option.
@end enumerate

If AutoGen fails to find the template file in one of these places,
it prints an error message and exits.

@node Definitions
@section Named Definitions
@cindex definitions

Any name may have multiple values associated with it in the definition
file.  If there is more than one instance, the @strong{only} way to
expand all of the copies of it is by using the FOR (@pxref{FOR}) text
function on it, as described in the next chapter.

There are two kinds of definitions, @samp{simple} and @samp{compound}.
They are defined thus (@pxref{Full Syntax}):

@example
compound_name '=' '@{' definition-list '@}' ';'

simple_name '=' string ';'

no_text_name ';'
@end example

@noindent
@code{No_text_name} is a simple definition with a shorthand empty string
value.  The string values for definitions may be specified in any of
several formation rules.

@menu
* Naming::                   Naming a Value
* def-list::                 Definition List
* double-quote-string::      Double Quote String
* single-quote-string::      Single Quote String
* simple-string::            An Unquoted String
* shell-generated::          Shell Output String
* scheme-generated::         Scheme Result String
* here-string::              A Here String
* concat-string::            Concatenated Strings
@end menu

@cindex simple definitions
@cindex compound definitions

@node Naming
@subsection Naming a Value

The names may be a simple name taking the next available index,
or may specify an index by name or number.  For example:

@example
txt_name
txt_name[2]
txt_name[ DEF_NAME ]
@end example
@noindent
@code{DEF_NAME} must be defined to have a numeric value.
If you do specify an index, you must take care not to cause conflicts.

@node def-list
@subsection Definition List

@code{definition-list} is a list of definitions that may or may not
contain nested compound definitions.  Any such definitions may
@strong{only} be expanded within a @code{FOR} block iterating over the
containing compound definition.  @xref{FOR}.

Here is, again, the example definitions from the previous chapter,
with three additional name value pairs.  Two with an empty value
assigned (@var{first} and @var{last}), and a "global" @var{group_name}.

@example
autogen definitions list;
group_name = example;
list = @{ list_element = alpha;  first;
         list_info    = "some alpha stuff"; @};
list = @{ list_info    = "more beta stuff";
         list_element = beta; @};
list = @{ list_element = omega;  last;
         list_info    = "final omega stuff"; @};
@end example

@node double-quote-string
@subsection Double Quote String

@cindex string, double quote
The string follows the C-style escaping (@code{\}, @code{\n}, @code{\f},
@code{\v}, etc.), plus octal character numbers specified as @code{\ooo}.
The difference from "C" is that the string may span multiple lines.
Like ANSI "C", a series of these strings, possibly intermixed with
single quote strings, will be concatenated together.

@node single-quote-string
@subsection Single Quote String

@cindex string, single quote
This is similar to the shell single-quote string.  However, escapes
@code{\} are honored before another escape, single quotes @code{'}
and hash characters @code{#}.  This latter is done specifically
to disambiguate lines starting with a hash character inside
of a quoted string.  In other words,

@example
foo = '
#endif
';
@end example

could be misinterpreted by the definitions scanner, whereas
this would not:

@example
foo = '
\#endif
';
@end example

@*
As with the double quote string, a series of these, even intermixed
with double quote strings, will be concatenated together.

@node shell-generated
@subsection Shell Output String
@cindex shell-generated string

@cindex string, shell output
This is assembled according to the same rules as the double quote string,
except that there is no concatenation of strings and the resulting string is
written to a shell server process.  The definition takes on the value of
the output string.

NB@:  The text is interpreted by a server shell.  There may be
left over state from previous @code{`} processing and it may
leave state for subsequent processing.  However, a @code{cd}
to the original directory is always issued before the new
command is issued.

@node simple-string
@subsection An Unquoted String

A simple string that does not contain white space @i{may} be left
unquoted.  The string must not contain any of the characters special to
the definition text (i.e. @code{"}, @code{#}, @code{'}, @code{(},
@code{)}, @code{,}, @code{;}, @code{<}, @code{=}, @code{>}, @code{[},
@code{]}, @code{`}, @code{@{}, or @code{@}}).  This list is subject to
change, but it will never contain underscore (@code{_}), period
(@code{.}), slash (@code{/}), colon (@code{:}), hyphen (@code{-}) or
backslash (@code{\\}).  Basically, if the string looks like it is a
normal DOS or UNIX file or variable name, and it is not one of two
keywords (@samp{autogen} or @samp{definitions}) then it is OK to not
quote it, otherwise you should.

@node scheme-generated
@subsection Scheme Result String

A scheme result string must begin with an open parenthesis @code{(}.
The scheme expression will be evaluated by Guile and the
value will be the result.  The AutoGen expression functions
are @strong{dis}abled at this stage, so do not use them.

@node here-string
@subsection A Here String
@cindex here-string

A @samp{here string} is formed in much the same way as a shell here doc.
It is denoted with a doubled less than character and, optionally, a
hyphen.  This is followed by optional horizontal white space and an
ending marker-identifier.  This marker must follow the syntax rules
for identifiers.  Unlike the shell version, however, you must not quote
this marker.  The resulting string will start with the first character
on the next line and continue up to but not including the newline that
precedes the line that begins with the marker token.  No backslash or
any other kind of processing is done on this string.  The characters are
copied directly into the result string.

Here are two examples:
@example
str1 = <<-  STR_END
        $quotes = " ' `
        STR_END;

str2 = <<   STR_END
        $quotes = " ' `
        STR_END;
STR_END;
@end example
The first string contains no new line characters.
The first character is the dollar sign, the last the back quote.

The second string contains one new line character.  The first character
is the tab character preceeding the dollar sign.  The last character is
the semicolon after the @code{STR_END}.  That @code{STR_END} does not
end the string because it is not at the beginning of the line.  In the
preceeding case, the leading tab was stripped.

@node concat-string
@subsection Concatenated Strings
@cindex concat-string

If single or double quote characters are used,
then you also have the option, a la ANSI-C syntax,
of implicitly concatenating a series of them together,
with intervening white space ignored.

NB@:  You @strong{cannot} use directives to alter the string
content.  That is,

@example
str = "foo"
#ifdef LATER
      "bar"
#endif
      ;
@end example

@noindent
will result in a syntax error.  The preprocessing directives are not
carried out by the C preprocessor.  However,

@example
str = '"foo\n"
#ifdef LATER
"     bar\n"
#endif
';
@end example

@noindent
@strong{Will} work.  It will enclose the @samp{#ifdef LATER}
and @samp{#endif} in the string.  But it may also wreak
havoc with the definition processing directives.  The hash
characters in the first column should be disambiguated with
an escape @code{\} or join them with previous lines:
@code{"foo\n#ifdef LATER...}.

@node Dynamic Text
@section Dynamic Text
@cindex Dynamic Definition Text

There are several methods for including dynamic content inside a definitions
file.  Three of them are mentioned above (@ref{shell-generated} and
@pxref{scheme-generated}) in the discussion of string formation rules.
Another method uses the @code{#shell} processing directive.
It will be discussed in the next section (@pxref{Directives}).
Guile/Scheme may also be used to yield to create definitions.

When the Scheme expression is preceeded by a backslash and single
quote, then the expression is expected to be an alist of
names and values that will be used to create AutoGen definitions.

@noindent
This method can be be used as follows:

@example
\'( (name  (value-expression))
    (name2 (another-expr))  )
@end example

@noindent
This is entirely equivalent to:

@example
name  = (value-expression);
name2 = (another-expr);
@end example

@noindent
Under the covers, the expression gets handed off to a Guile function
named @code{alist->autogen-def} in an expression that looks like this:

@example
(alist->autogen-def
    ( (name (value-expression))  (name2 (another-expr)) ) )
@end example

@node Directives
@section Controlling What Gets Processed
@cindex directives

Definition processing directives can @strong{only} be processed
if the '#' character is the first character on a line.  Also, if you
want a '#' as the first character of a line in one of your string
assignments, you should either escape it by preceding it with a
backslash @samp{\}, or by embedding it in the string as in @code{"\n#"}.

All of the normal C preprocessing directives are recognized, though
several are ignored.  There is also an additional @code{#shell} -
@code{#endshell} pair.  Another minor difference is that AutoGen
directives must have the hash character (@code{#}) in column 1.

The ignored directives are:
@ignore
END   == MAIN == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == COMMENTS == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
Resume input from autogen.texi
@end ignore

@node Predefines
@section Pre-defined Names
@cindex predefines

When AutoGen starts, it tries to determine several names from the
operating environment and put them into environment variables for use in
both @code{#ifdef} tests in the definitions files and in shell scripts
with environment variable tests.  For these names, it will first try to
use the POSIX version of the @code{sysinfo(2)} system call.  Failing
that, it will try for the POSIX @code{uname(2)} call.  If neither is
available, then this feature is not supported.

If @code{sysinfo(2)} is available, the strings associated with

@itemize @bullet
@item
@code{SI_SYSNAME} (e.g., "__sunos__")
@item
@code{SI_HOSTNAME} (e.g., "__ellen__")
@item
@code{SI_ARCHITECTURE} (e.g., "__sparc__")
@item
@code{SI_HW_PROVIDER} (e.g., "__sun_microsystems__")
@item
@code{SI_PLATFORM} (e.g., "__sun_ultra_5_10__")
@item
@code{SI_MACHINE} (e.g., "__sun4u__")
@end itemize
@noindent
are used.  The associated names are converted to lower case, surrounded
by doubled underscores and non-symbol characters are replaced with
underscores.  For example, for Solaris on a sparc platform, you would
get these definitions:

For Linux and other operating systems that only support the
@code{uname(2)} call, AutoGen will use these values:

@itemize @bullet
@item
@code{sysname} (e.g., "__linux__")
@item
@code{machine} (e.g., "__i586__")
@item
@code{nodename} (e.g., "__bach__")
@end itemize

By testing these pre-defines in my definitions, I can select
pieces of the definitions without resorting to writing shell
scripts that parse the output of @code{uname(1)}.

@example
#ifdef __bach__
  location = home;
#else
  location = work;
#endif
@end example

@node Comments
@section Commenting Your Definitions
@cindex comments

The definitions file may contain C-style comments.

@example
/*
 *  This is a comment.
 *  It continues for several lines and suppresses all processing
 *  until the closing characters '*' and '/' appear together.
 */
@end example

@node Example
@section What it all looks like.

@noindent
This is an extended example:

@example
autogen definitions @samp{template-name};
/*
 *  This is a comment that describes what these
 *  definitions are all about.
 */
global = "value for a global text definition.";

/*
 *  Include a standard set of definitions
 */
#include standards.def

a_block = @{
    a_field;
    /*
     *  You might want to document sub-block definitions, too
     */
    a_subblock = @{
        sub_name  = first;
        sub_field = "sub value.";
    @};

#ifdef FEATURE
    /*
     *  This definition is applicable only if FEATURE
     *  has been defined during the processing of the definitions.
     */
    a_subblock = @{
        sub_name  = second;
    @};
#endif

@};

a_block = @{
    a_field = here;
@};
@end example

@ignore
END   == COMMENTS == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == TEMPLATE == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@node Definition-less
@section AutoGen without Definitions
@cindex Definition-less

It is entirely possible to write a template that does not depend upon
external definitions.  Such a template would likely have an unvarying
output, but be convenient nonetheless because of an external library
of either AutoGen or Scheme functions, or both.  This can be accommodated
by providing the @code{--override-tpl} and @code{--no-definitions}
options on the command line.  @xref{autogen Invocation}.

@ignore
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
@end ignore
@page
@node Template File
@chapter AutoGen Template
@cindex template file
@cindex .tpl file

The AutoGen template file defines the content of the output text.
It is composed of two parts.  The first part consists of a pseudo
macro invocation and commentary.  It is followed by the template proper.

@cindex pseudo macro
@cindex macro, pseudo
This pseudo macro is special.  It is used to identify the file as a
AutoGen template file, fixing the starting and ending marks for
the macro invocations in the rest of the file, specifying the list
of suffixes to be generated by the template and, optionally, the
shell to use for processing shell commands embedded in the template.

AutoGen-ing a file consists of copying text from the template to the
output file until a start macro marker is found.  The text from the
start marker to the end marker constitutes the macro text.  AutoGen
macros may cause sections of the template to be skipped or processed
several times.  The process continues until the end of the template is
reached.  The process is repeated once for each suffix specified in the
pseudo macro.

This chapter describes the format of the AutoGen template macros
and the usage of the AutoGen native macros.  Users may augment
these by defining their own macros.  @xref{DEFINE}.

@menu
* pseudo macro::       Format of the Pseudo Macro
* naming values::      Naming a value
* expression syntax::  Macro Expression Syntax
* AutoGen Functions::  AutoGen Scheme Functions
* Common Functions::   Common Scheme Functions
* native macros::      AutoGen Native Macros
* output controls::    Redirecting Output
@end menu

@node pseudo macro
@section Format of the Pseudo Macro
@cindex pseudo macro

The pseudo-macro starts with up to seven (7) punctuation characters used
for the template start-macro marker, followed by the autogen magic
marker (@code{autogen5}), the template marker (@code{template}), zero or
more suffix specifications, scheme expressions and the end-macro marker.
It may also consist of up to seven (7) punctuation characters.  Interspersed
may be comment lines (blank lines or lines starting with a hash mark
[@code{#}]) and edit mode markers (text between pairs of @code{-*-}
characters).

As an example, assume we want to use @code{[+} and @code{+]} as the start
and end macro markers, and we wish to produce a @file{.c} and a @file{.h}
file, then the first macro invocation will look something like this:

@example
[+ AutoGen5 template -*- Mode: emacs-mode-of-choice -*-

h=chk-%s.h

c +]
@end example

@noindent
Note@:  It is generally a good idea to use some sort of opening
bracket in the starting macro and closing bracket in the ending
macro  (e.g. @code{@{}, @code{(}, @code{[}, or even @code{<}
in the starting macro).  It helps both visually and with editors
capable of finding a balancing parenthesis.  The closing marker
may @strong{not} begin with an open parenthesis, as that is used
to enclose a scheme expression.

It is also helpful to avoid using the comment marker (@code{#});
the POSIXly acceptable file name characters period (@code{.}),
hyphen (@code{-}) and underscore (@code{_}); and finally, it is
advisable to avoid using any of the quote characters@:  double,
single or back-quote.  But there is no special check for any of
these advisories.

@noindent
Detailed description:

The starting macro marker must be the first non-white space characters
encountered in the file.  The marker consists of all the contiguous
ASCII punctuation characters found there.  With optional intervening
white space, this marker must be immediately followed by the keywords,
"autogen5" and "template".  Capitalization of these words is not
important.  This is followed by zero, one or more suffix specifications
and, possibly, a scheme expression.

Suffix specifications consist of a sequence of POSIX compliant file name
characters and, optionally, an equal sign and a file name "printf"-style
formatting string.  Two string arguments are allowed for that string:
the base name of the definition file and the current suffix (that being
the text to the left of the equal sign).  (Note@: "POSIX compliant file
name characters" consist of alphanumerics plus the period (@code{.}),
hyphen (@code{-}) and underscore (@code{_}) characters.)  If there are
no suffix specifications, then the generated file will be written to the
stdout file descriptor.

The scheme expression is intended to allow the template writer to specify
the shell program that must be used to interpret the shell commands in
the template.  It can have no effect on any shell commands in the 
definitions file, as that file will have been processed by the time
the pseudo macro is interpreted.  You can specify the shell as follows:

@example
(setenv "SHELL" "/bin/sh")
@end example

@noindent
This works because AutoGen examines the value of the SHELL environment
variable in order to select the shell to run.  If that shell is allowed
to be @code{csh}, AutoGen will break.  If it is allowed to be @code{zsh},
AutoGen may break.  Your milage may vary.

The pseudo macro ends with an end macro marker.  Like the starting macro
marker, it consists of a contiguous sequence of arbitrary punctuation
characters.  However, additionally, it may not begin with any of the
POSIX file name characters and it may not contain the start macro
marker.

This pseudo macro may appear on one or several lines of text.
Intermixed may be comment lines (completely blank or starting with the
hash character @code{#} in column 1), and file content markers (text
between @code{-*-} pairs on a single line).  This may be used to
establish editing "modes" for the file.  These are ignored by
AutoGen.

The template proper starts after the pseudo-macro.  The starting
character is either the first non-whitespace character or the first
character after the new-line that follows the end macro marker.

@node naming values
@section Naming a value
@cindex naming values

When an AutoGen value is specified in a template, it is specified by name.
The name may be a simple name, or a compound name of several components.
Since each named value in AutoGen is implicitly an array of one or more
values, each component may have an index associated with it.

@noindent
It looks like this:

@example
comp-name-1 . comp-name-2 [ 2 ]
@end example

Note that if there are multiple components to a name, each component
name is separated by a dot (@code{.}).  Indexes follow a component name,
enclosed in square brackets (@code{[} and @code{]}).  The index may be
either an integer or an integer-valued define name.  The first component
of the name is searched for in the current definition level.  If not
found, higher levels will be searched until either a value is found,
or there are no more definition levels.  Subsequent components of the
name must be found within the context of the newly-current definition
level.  Also, if the named value is prefixed by a dot (@code{.}), then
the value search is started in the current context only.  No higher
levels are searched.

If someone rewrites this, I'll incorporate it.  :-)

@node expression syntax
@section Macro Expression Syntax
@cindex expression syntax

The syntax of a full AutoGen expression is:

@example
[[ <apply-code> ] <value-name> ] [ <simple-expr-1> [ <simple-expr-2> ]]
@end example
@noindent
Where
@table @samp
@item <apply-code>
is any of @code{-}, @code{?}, @code{%} or @code{?%} (see below).
@item <value-name>
is a (possibly unknown) AutoGen value name (@xref{naming values},
and @pxref{EXPR}).  In this context, the name may not contain any
white space.
@item <simple-expr-1>
is either a Scheme expression starting with @code{;} or @code{(};
a shell expression surrounded with @code{`}; or a string, quoted or
unquoted.
@item <simple-expr-2>
is as above, but only if the @code{?} or @code{?%} apply-code has
been specified.
@end table

There are some places where only a simple expression (i.e. just the
@code{<simple-expr-1>} clause) is allowed.  I hope I have clearly
marked which macros have those requirements.  Otherwise, in the
macro descriptions that follow, a @i{full expression} refers to
what we are describing here.

The result of the expression evaluation will depend on what apply code
has been provided, whether or not there is an associated value
for the value name, and whether or not expressions are specified.

The syntax rules are:

@enumerate
@item
The expression may not be empty.
@item
If no value name is provided, then the rest of the macro is presumed to
be an expression and is evaluated.  It usually must start with one of
the expression processing characters.  See below.
@item
If no expression is provided, then there must be a value name
and there may not be an apply code.  The result will either be
the empty string, or the AutoGen value associated with value name.
@item
If the apply code is either @code{?} or @code{?%}, then two
expressions must be provided, otherwise only one expression
may be provided.
@end enumerate

The apply codes used are as follows:

@table @samp
@item @code{-}
The expression that follows the value name will be processed
only if the named value is @strong{not} found.

@item @code{?}
There must be @strong{two} space separated expressions following
the value name.  The first is selected if the value name is found,
otherwise the second expression is selected.

@item @code{%}
The first expression that follows the name will be used as a
format string to sprintf.  The data argument will be the value
named after the @code{%} character.

@item @code{?%}
This combines the functions of @code{?}and @code{%}, but for
obvious reasons, only the first expression will be used as a
format argument.

@item not-supplied
The macro will be skipped if there is no AutoGen value associated with
the @code{<value-name>}.  If there is an associated value, then the
expression result is the result of evaluating @code{<expression-1>}
(if present), otherwise it is the value associated with
@code{<value-name>}.
@end table

The simple expression clauses are interpreted differently,
depending on the first character:

@table @samp
@item @code{;} (semi-colon)
This is a Scheme comment character and must preceed Scheme code.
AutoGen will strip it and pass the result to the Guile Scheme
interpreter.

@item @code{(} (open parenthesis)
This is a Scheme expression.  Guile will interpret it.
The expression must end before the end macro marker.

@item @code{'} (single quote)
This is a @i{fairly} raw text string.  It is not completely raw
because backslash escapes are processed before 3 special characters:
single quote (@code{'}), the hash character (@code{#}) and
backslash (@code{\}).

@item @code{"} (double quote)
This is a cooked text string.  The string is processed as in a
K and R quoted string.  That is to say, adjacent strings are not
concatenated together.

@item @code{`} (back quote)
This is a shell expression.  The AutoGen server shell will
interpret it.  The result of the expression will be the
output of the shell script.  The string is processed as in
the cooked string before being passed to the shell.

@item anything else
Is presumed to be a literal string.  It becomes the result
of the expression.
@end table

@ignore
END   == TEMPLATE == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == MACROS == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@node native macros
@section AutoGen Native Macros
@cindex native macros

This section describes the various AutoGen natively defined macros.
The general syntax is:

@example
[ @{ <native-macro-name> | <user-defined-name> @} ] [ <arg> ... ]
@end example

@noindent
The syntax for @code{<arg>} depends on the particular macro,
but is generally a full expression (@pxref{expression syntax}).
Here are the exceptions to that general rule:

@enumerate
@item
@code{INVOKE} macros, implicit or explicit, must be followed by
a list of name/string value pairs.  The string values are
@i{simple expressions}, as described above.

That is, the @code{INVOKE} syntax is either:
@example
<user-macro-name> [ <name> [ = <expression> ] ... ]
@end example
@noindent
or
@example
INVOKE <name-expression> [ <name> [ = <expression> ] ... ]
@end example

@item
AutoGen FOR macros must be in one of two forms:

@example
FOR <name> [ <separator-string> ]
@end example
@noindent
or
@example
FOR <name> (...Scheme expression list)
@end example
@noindent
where @code{<name>} must be a simple name and the Scheme expression list
is expected to contain one or more of the @code{for-from},
@code{for-to}, @code{for-by}, and @code{for-sep} functions.
(@xref{FOR}, and @ref{AutoGen Functions})

@item
AutoGen @code{DEFINE} macros must be followed by a simple name.
Anything after that is ignored.  @xref{DEFINE}.

@item
The AutoGen @code{COMMENT}, @code{ELSE}, @code{ESAC} and the @code{END*}
macros take no arguments and ignore everything after the macro name
(e.g. see @ref{COMMENT})
@end enumerate

@noindent
These are the AutoGen native macros:
@ignore
END   == MACROS == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == AUGMENTING == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@node output controls
@section Redirecting Output
@cindex Redirecting Output

AutoGen provides a means for redirecting the template output
to different files.  It is accomplished by providing a set of
Scheme functions named @code{out-*} (@pxref{AutoGen Functions}).

These functions allow you to logically "push" output files onto a stack
and return to previous files by "pop"ing them back off.  At the end of
processing the template for a particular suffix (@pxref{pseudo macro}),
all the files in the output stack are closed and popped off.
Consequently, at the start of the processing of a template, there is
only one output file on the stack.  That file cannot be popped off.

There are also several functions for determining the output
status.  @xref{AutoGen Functions}.

@ignore

* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

@end ignore

@page
@node Augmenting AutoGen
@chapter Augmenting AutoGen
@cindex Augmenting AutoGen

AutoGen was designed to be simple to enhance.  You can do it by
providing shell commands, Guile/Scheme macros or callout functions
that can be invoked as a Guile macro.  Here is how you do these.

@menu
* shell commands::       Shell Output Commands
* guile macros::         Guile Macros
* guile callouts::       Guile Callout Functions
* AutoGen macros::       AutoGen Macros
@end menu

@node shell commands
@section Shell Output Commands

Shell commands are run inside of a server process.  This means that,
unlike @file{make}, context is kept from one command to the next.
Consequently, you can define a shell function in one place inside of
your template and invoke it in another.  You may also store values
in shell variables for later reference.  If you load functions from
a file containing shell functions, they will remain until AutoGen exits.

@node guile macros
@section Guile Macros

Guile also maintains context from one command to the next.  This means
you may define functions and variables in one place and reference them
elsewhere.  You also may load Guile macro definitions from a Scheme
file by using the @code{--load-scheme} command line option
(@pxref{autogen load-scheme}).  Beware,
however, that the AutoGen specific scheme functions have not been loaded
at this time, so though you may define functions that reference them,
do not invoke the AutoGen functions at this time.

@node guile callouts
@section Guile Callout Functions

Callout functions must be registered with Guile to work.  This can
be accomplished either by putting your routines into a shared library
that contains a @code{void scm_init( void )} routine that registers
these routines, or by building them into AutoGen.

To build them into AutoGen, you must place your routines in the source
directory and name the files @file{exp*.c}.  You also must have a stylized
comment that @file{getdefs} can find that conforms to the following:

@example
/*=gfunc <function-name>
 *
 *  what:    <short one-liner>
 *  general_use:
 *  string:  <invocation-name-string>
 *  exparg:  <name>, <description> [, ['optional'] [, 'list']]
 *  doc:     A long description telling people how to use
 *           this function.
=*/
SCM
ag_scm_<function-name>( SCM arg_name[, ...] )
@{ <code> @}
@end example

@table @samp
@item gfunc
You must have this exactly thus.

@item <function-name>
This must follow C syntax for variable names

@item <short one-liner>
This should be about a half a line long.
It is used as a subsection title in this document.

@item general_use:
You must supply this unless you are an AutoGen maintainer and are writing
a function that queries or modifies the state of AutoGen.

@item <invocation-name-string>
Normally, the @code{function-name} string will be transformed into
a reasonable invocation name.  However, that is not always true.
If the result does not suit your needs, then supply an alternate string.

@item exparg:
You must supply one for each argument to your function.
All optional arguments must be last.
The last of the optional arguments may be a list, if you choose.

@item doc:
Please say something meaningful.

@item [, ...]
Do not actually specify an ANSI ellipsis here.  You must provide
for all the arguments you specified with @code{exparg}.
@end table

See the Guile documentation for more details.
More information is also available in a large comment at the
beginning of the @file{agen5/snarf.tpl} template file.

@node AutoGen macros
@section AutoGen Macros

There are two kinds@:  those you define yourself and AutoGen native.
The user-defined macros may be defined in your templates or loaded
with the @code{--lib-template} option
(See @ref{DEFINE} and  @ref{autogen lib-template}).

As for AutoGen native macros, do not add any. It is easy to do, but I
won't like it.  The basic functions needed to accomplish looping over
and selecting blocks of text have proven to be sufficient over a period
of several years.  New text transformations can be easily added via any
of the AutoGen extension methods, as discussed above.

@ignore
END   == AUGMENTING == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == INSTALLATION == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@page
@node Installation
@chapter What Gets Installed Where
@cindex Installation

There are several files that get installed.  The number depend
whether or not both shared and archive libraries are to be
installed.  The following assumes that everything is installed
relative to @code{$prefix}.  You can, of course, use
@code{configure} to place these files where you wish.

@strong{NB}@:  AutoGen does not contain any compiled-in path names.
All support directories are located via option processing
and the environment variable @code{HOME}.

The installed files are:

@enumerate
@item
The executables in @file{bin} (autogen, getdefs and columns).

@item
The AutoOpts link libraries as @file{lib/libopts.*}.

@item
An include file in @file{include/options.h}, needed for
Automated Option Processing (see next chapter).

@item
Several template files and a scheme script in @file{share/autogen}, needed
for Automated Option Processing (@pxref{AutoOpts}), parsing definitions
written with scheme syntax (@pxref{Dynamic Text}), the templates for
producing documentation for your program (@pxref{documentation attributes}),
and AutoFSM.

@item
Info-style help files as @file{info/autogen.info*}.
These files document AutoGen, the option processing
library AutoOpts, and several add-on components.

@item
The three man pages for the three executables are installed in man/man1.
@end enumerate

This program, library and supporting files can be installed
with two commands:

@itemize @bullet
@item
<src-dir>/configure [ <configure-options> ]
@item
make install
@end itemize

However, you may wish to insert @code{make}
and @code{make check} before the second command.

If you do perform a @code{make check} and there are any failures, you
will find the results in @code{tests/FAILURES}.  Needless to say, I
would be interested in seeing the contents of those files and any
associated messages.  If you choose to go on and analyze one of these
failures, you will need to invoke the test scripts individually.  You
may do so by specifying the test (or list of test) in the TESTS make
variable, thus:

@example
make TESTS=test-name.test check
@end example

All of the AutoGen tests are written to honor the contents of the
@t{VERBOSE} environment variable.  Normally, any commentary generated
during a test run is discarded unless the @t{VERBOSE} environment
variable is set.  So, to see what is happening during the test, you
might invoke the following with @i{bash} or @i{ksh}:

@example
VERBOSE=1 make TESTS="for.test forcomma.test" check
@end example

Or equivalently with @i{csh}:

@example
env VERBOSE=1 make TESTS="for.test forcomma.test" check
@end example

@ignore
END   == INSTALLATION == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == AUTOOPTS == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

AutoOpts is distributed under The GNU General Public License with the
Library extentions (LGPL).  It is in no way a "lesser" license.
You have greater license with it.

@menu
* Features::          AutoOpts Features
* Comparison::        Competitive Feature Analysis
* Quick Start::       Quick Start
* opts.def::          Option Definitions File
* AutoOpts API::      Programmatic Interface
* option descriptor:: Option Descriptor File
* Using AutoOpts::    Using AutoOpts
* shell options::     AutoOpts for Shell Scripts
* AutoInfo::          Automated @samp{Invoking Info} Doc
* AutoMan pages::     Automated Man Pages
@end menu

@node Features
@section AutoOpts Features
@cindex features

AutoOpts supports option processing; option state saving; and
program documentation with the following features:

@enumerate
@item
POSIX-compliant short (flag) option processing, if your options specify
at least one option @code{value} (@pxref{Optional Attributes}).

@item
GNU-style long options processing, if you specify @code{long-opts}
(@pxref{program attributes}) as a global program attribute.  Long options
are recognized without case sensitivity, and they may be abbreviated to
the minimum length that is unique within the set of program options.

@item
Process environment variable initializations, if the @code{environrc}
program attribute is specified and the variable(s) exist.
@xref{program attributes}.

@item
Process initialization/rc files, if the @code{homerc} program attribute(s)
are specified and the file(s) exist).  @xref{loading rc files},
and @xref{program attributes}.

@item
Store the option state into an initialization/rc file.
@xref{saving rc files}.

@item
Options may stand by themselves or have required or optional arguments.

@item
Option arguments may be arbitrary strings or constrained to numbers
or a list of keywords.

@item
Options may default to an enabled or a disabled state.  If they default
to enabled, then you must provide a disablement prefix to allow users
to disable the option.

@item
If you provide a disablement prefix, then you may provide an enablement
prifix, too.  e.g., @code{--allow-mumble} and @code{--prevent-mumble}.

@item
Verify that required options are present the
required minimum number of times on the command line.
@xref{Optional Attributes}.

@item
Verify that options do not appear more than the maximum number
of times.
@xref{Optional Attributes}.

@item
Verify that conflicting options do not appear together.
@xref{Multiply Optional}.

@item
Verify that options that require the presence of other options
are, in fact, used in the presence of other options.
@xref{Multiply Optional}.

@item
Provides a callable routine (@pxref{optionLoadLine}) to parse a line of
text as if it were a line from one of the RC/INI files.  (Consequently,
you may stash options in a text file you process and pass the relevant
text for option processing.)

@item
@code{help} and @code{more-help} are automatically supported.
@code{more-help} will automatically page the generated help.
AutoOpts produces usage information through the library routine
@code{optionUsage()}.  It will print out the invocation syntax and a
list of every option.

@noindent
Two levels of usage are supported.  If the user supplies an invalid
(unknown) option, then the @i{brief} mode is emitted.  That contains
simply the usage line and listing of valid options.  The @i{extended}
mode is used when the @samp{--help} or @samp{--more-help} is specified
on the command line.  This mode will add information about how the
option is treated (if there is any special treatment for it), and it
will display any @samp{detail} text specified for the program.

@item
By adding a @samp{doc} and @samp{arg_name} attributes to each option,
AutoGen will also be able to produce a man page and the @samp{invoking}
section of a texinfo document.  These documentation templates will also
weave in the @samp{explain} and @samp{detail} program attributes as well.

@item
Produce a #define for the program version that can be
used by the library routine @samp{doVersion()}.

@item
Insert the option processing state into Scheme-defined variables.
Thus, Guile based applications that are linked with private
@code{main()} routines can take advantage of all of AutoOpts' functionality.

@item
If @code{TEST_MAIN} is defined, the output @file{.c} file will contain a
main routine that will be compiled when @code{TEST_<prog-name>_OPTS} is
defined.  @xref{shell options}.  If you choose to compile this program,
it is currently capable of producing one of three results:

@enumerate a
@item
If @code{TEST_MAIN} is defined to contain 3 or fewer characters
(e.g., "yes"), then it will produce a program that processes the
arguments and writes to standard out portable shell commands
containing the digested options (i.e., it will call @code{putBourneShell}).

@item
If @code{TEST_MAIN} is set to @code{putShellParse}, it will produce a
program that will generate portable shell commands to parse the defined
options.  The expectation is that this result will be copied into a
shell script and used there.

@item
If @code{TEST_MAIN} is set to anything else, it must be
a routine name and that routine will be called with
a pointer to the option descriptions as the single argument.
You must supply this routine and, obviously, you can
cause it to do whatever you wish it to do.
@end enumerate

@item
Long options can be specified as having enabling or disabling prefixes.
For example, the @code{mumble} option may have an enabling @code{must}
prefix and a disabling @code{dont}, yielding @code{--must-mumble} and
@code{--dont-mumble} as recognized options.  @code{--mumble} will
@strong{not} be recognized.

@item
If a global program attribute @code{version} is supplied, then
a GNU-compliant @samp{--version} option will be supported.

@item
There are facilities in place to allow libraries to intermingle their
command line and initialization options with client program options.
@end enumerate

@noindent
Explanatory details:
@menu
* loading rc files::  loading rc files
* saving rc files::   saving rc files
* optionLoadLine::    process a text string for options
@end menu

@node loading rc files
@unnumberedsubsec loading rc files
@cindex loading rc files
Initialization files are enabled by specifying the program attribute
@code{homerc} (@pxref{program attributes}).  The initialization values
are identified by the long option name followed by white space and any
associated value.  The value, if any, will continue through the end of
the last line not continued with a backslash.  Leading and trailing
white space is stripped.

Initialization files are selected both by the @code{homerc} entries and,
optionally, via an automatically supplied command line option.  The
first component of the @code{homerc} entry may be an environment
variable such as @code{$HOME}, or it may also be @code{$$} (@strong{two}
dollar sign characters) to specify the directory of the executable.
For example:

@example
homerc = "$$/../share/autogen";
@end example

The initialization files are processed in the order they are specified
by the @code{homerc} attribute, so that each new file will normally
override the settings of the previous files.  A few options may be
marked for @code{immediate action} (@pxref{immediate action}).  Any such
options are acted upon in @strong{reverse} order.  The disabled
@code{load-opts} (@code{--no-load-opts}) option, for example, is an
immediate action option.  Its presence in the last @code{homerc} file
will prevent the processing of any prior @code{homerc} files.

Further initialization file processing can be @strong{suppressed} by
specifying @code{--no-load-opts} on the command line, or
@code{PROGRAM_LOAD_OPTS=no} in the environment, or @code{no-load-opts}
in any of the specified @code{homerc} files.

@noindent
will cause the AutoOpts library to look in the normal autogen datadir
for an initialization file.

@node saving rc files
@unnumberedsubsec saving rc files
@cindex saving rc files
When initialization files are enabled for an application, the user is
also provided with an automatically supplied @code{--save-opts} option.
All of the known option state will be written to either the specified
output file or, if it is not specified, then to the last specified
@code{homerc} file.

@node optionLoadLine
@unnumberedsubsec process a text string for options
@cindex optionLoadLine
This routine expects a NUL-terminated string to contain a long option
name followed, optionally, by a string value.  Leading and trailing
white space is trimmed from the value, but otherwise new lines are
not discarded.  The caller is expected to have NUL terminated the
string at the correct point.

@page
@node Comparison
@section Competitive Feature Analysis

Here is a feature comparison of AutoOpts and five other command line
parser generators.  They all read a file that describes the program
options and produce code to parse command line options.  Each has their
own format for describing options.

All versions support both short options (flags) and GNU-type long
options.  clig, however, is unique in that you must choose one or the
other.  Either way, clig options are introduced with a single hyphen.
The other packages identify long options with doubled hyphens.

@enumerate
@item
AutoOpts is a component of AutoGen.  AutoGen has many capabilities, but
here we concentrate on the portion called AutoOpts.  AutoOpts is the
most general of these programs, and has the most extensive
documentation.  It is the only one that supports shell scripts as well
as C programs.  It also supports command option processing from a configuration
file or the environment.

@item
clig generates a skeleton man page and can also update a previously
generated man page.

@item
genparse.

@item
gaa supports option input from a configuration file as well as the
command line.  NOTE HOWEVER: gaa is not maintained.

@item
gengetopt is the only one that generates a skeleton main.c
instead of a separate parsing function.  Since you must edit this
file to create your program, rerunning gengetopt will wipe out
any such changes.

@item
wyg uses flex and bison to generate a configuration file parser,
but uses getopt_long to parse the command line options.
@end enumerate

@multitable @columnfractions .26 .1 .1 .1 .1 .1 .1
@item package
@tab 1
@tab 2
@tab 3
@tab 4
@tab 5
@tab 6
@item C language app
@tab yes
@tab yes
@tab yes
@tab yes
@tab yes
@tab yes
@item shell script app
@tab yes
@tab no
@tab no
@tab no
@tab no
@tab no
@item package result
@tab parser
@tab parser
@tab parser
@tab parser
@tab main.c
@tab parser
@item config file input
@tab yes
@tab no
@tab no
@tab yes
@tab no
@tab yes
@item environment input
@tab yes
@tab no
@tab no
@tab no
@tab no
@tab no
@item config file output
@tab yes
@tab no
@tab no
@tab no
@tab no
@tab no
@item command line
@tab yes
@tab yes
@tab yes
@tab yes
@tab yes
@tab yes
@item parameter types
@tab [1]
@tab 4
@tab 5
@tab 5
@tab 11
@tab 4
@item callback functions
@tab yes
@tab no
@tab yes
@tab yes
@tab yes
@tab no
@item multiple parameters
@tab yes
@tab yes
@tab no
@tab no
@tab no
@tab no
@item optional parameters
@tab yes
@tab yes
@tab no
@tab no
@tab no
@tab no
@item default values
@tab yes
@tab yes
@tab yes
@tab yes
@tab no
@tab yes
@item range checks
@tab no
@tab yes
@tab yes
@tab no
@tab no
@tab no
@item enumeration options
@tab yes
@tab no
@tab no
@tab no
@tab no
@tab no
@item option data
@tab struct
@tab struct
@tab struct
@tab struct
@tab vars
@tab struct
@item usage()
@tab yes
@tab yes
@tab yes
@tab yes
@tab yes
@tab yes
@item man page
@tab yes
@tab yes
@tab no
@tab no
@tab no
@tab no
@item texinfo usage
@tab yes
@tab no
@tab no
@tab no
@tab no
@tab no
@item makefile
@tab no
@tab no
@tab no
@tab no
@tab no
@tab no
@item developer dependencies
@tab Guile
@tab tcl
@tab none
@tab none
@tab none
@tab bison,flex
@item user dependencies
@tab [2]
@tab none
@tab none
@tab none
@tab none
@tab none
@end multitable

 [1] See the lengthy list of features @xref{Features}.

 [2] There is a user-visible dependency iff the developer does a
dynamic link to the libopts.so library.  Developers are free to either
link statically or ship libopts.so with their product.  A Debian
package would need only a dependency on the package supplying libopts
(libopts9, at present).

 The Guile library is now generally pre-installed on all GNU/Linux systems.

 -- James R. Van Zandt
@page
@node Quick Start
@section Quick Start
@cindex Quick Start

Since it is generally easier to start with a simple example than it is
to look at the options that AutoGen uses itself, here is a very simple
AutoOpts example.  You can copy this example out of the Info file and
into a source file to try it.  You can then embellish it into what you
really need.

Assume you have a program named @code{check} that takes
two options:

@enumerate
@item
A list of directories to check over for whatever it is @code{check} does.
You want this option available as a POSIX-style flag option
and a GNU long option.  You want to allow as many of these
as the user wishes.
@item
An option to show or not show the definition tree being used.
Only one occurrence is to be allowed, specifying one or the other.
@end enumerate

@noindent
First, specify your program attributes and its options to AutoOpts,
as with the following example.

@smallexample
AutoGen Definitions options;
prog-name     = check;
prog-title    = "Checkout Automated Options";
long-opts;

flag = @{
    name      = check_dirs;
    value     = L;        /* flag style option character */
    arg_type  = string;   /* option argument indication  */
    max       = NOLIMIT;  /* occurrence limit (none)     */
    stack_arg;            /* save opt args in a stack    */
    descrip   = "Checkout directory list";
@};

flag = @{
    name      = show_defs;
    descrip   = "Show the definition tree";
    disable   = dont;     /* mark as enable/disable type */
                          /* option.  Disable as `dont-' */
@};
@end smallexample

@noindent
Then perform the following steps:

@enumerate
@item
@code{autogen -L $prefix/share/autogen -DTEST_MAIN=yes checkopt.def}
@item
@code{cc -o check -DTEST_CHECK_OPTS -g checkopt.c -L $prefix/lib -lopts}
@end enumerate

@noindent
And now, @code{./check --help} yields:

@smallexample
check - Checkout Automated Options
USAGE:  check [-<flag> [<val>]]... [--<name>[@{=| @}<val>]]...
  Flg Arg Option-Name    Description
   -L YES check-dirs     Checkout directory list
                                - may appear without limit
      no  show-defs      Show the definition tree
                                - disabled as --dont-show-defs
   -? no  help           Display usage information and exit
   -! no  more-help      Extended usage information passed thru pager

Options may be specified by doubled markers and their name
or by a single marker and the flag character/option value.
@end smallexample

Normally, however, you would compile @file{checkopt.c} as in:

@smallexample
cc -o checkopt.o -I$prefix/include -c checkopt.c
@end smallexample

and link @file{checkopt.o} with the rest of your program.
The main program causes the options to be processed
by calling @code{optionProcess}:

@smallexample
main( int argc, char** argv )
@{
  @{
    int optct = optionProcess( &checkOptions, argc, argv );
    argc -= optct;
    argv += optct;
  @}
@end smallexample

The options are tested and used as in the following fragment:

@smallexample
  if (HAVE_OPT( SHOW_DEFS )) @{
    int    dirct = STACKCT_OPT( CHECK_DIRS );
    char** dirs  = STACKLST_OPT( CHECK_DIRS );
    while (dirct-- > 0) @{
      char* dir = *dirs++;
      ...
@end smallexample

A lot of magic happens to make this happen.
The rest of this chapter will help you learn how to specify
the option processing and how to examine the resulting state.

@node opts.def
@section Option Definitions File
@cindex opts.def

This file contains the AutoGen definitions that describe the options for
a particular program.  There are several groups of definitions.  The
first describes the program and over-all option processing attributes.
The second group describes the name, usage and other attributes related
to each option.  The third group are used for documenting your program
and are @strong{not} used for command line processing.  The last section
below will describe the command line options that are automatically
provided by AutoOpts.

The list of program and option attributes is quite extensive.  Keep in
mind that the majority are rarely used and can be safely ignored.
However, when you have special option processing requirements, the
flexibility is there.

@menu
* program attributes::        Program Description Attributes
* option attributes::         Option Attributes
* documentation attributes::  Man and Info doc Attributes
* immediate action::          Immediate Action Attributes
* standard options::          Automatically Supported Options
@end menu

@node program attributes
@subsection Program Description Attributes
@cindex program attributes

The following global option definitions are used to define attributes of
the entire program.  The first two are required of every program.  The
rest have been alphabetized.  Except as noted, there may be only one
copy of each of these definitions:

@table @samp
@cindex prog-name
@item prog-name
This attribute is required.  Variable names derived from this name will
be transformed via @code{string->c_name!} (@pxref{SCM string->c-name!}).

@cindex prog-title
@item prog-title
This attribute is required and may be any descriptive text.

@cindex prog_desc
@item prog_desc @strong{and}
@cindex opts_ptr
@itemx opts_ptr
These define global pointer variables that point to the program
descriptor and the first option descriptor for a library option.  This
is intended for use by certain libraries that need command line and/or
initialization file option processing.  These definitions have no effect
on the option template output, but are used for creating a library
interface file.  Normally, the first "option" for a library will be a
documentation option that cannot be specified on the command line, but
is marked as @code{settable}.  The library client program will invoke the
@code{SET_OPTION} macro which will invoke a handler function that will
finally set these global variables.

@cindex allow_errors
@item allow_errors
The presence of this attribute indicates ignoring any command line
option errors.  This may also be turned on and off by invoking the
macros @code{ERRSKIP_OPTERR} and @code{ERRSTOP_OPTERR} from the
generated interface file.

@cindex argument
@item argument
Specifies the syntax of the arguments that @strong{follow} the options.
It may not be empty, but if it is not supplied, then option processing
must consume all the arguments.  If it is supplied and starts with an
open bracket (@code{[}), then there is no requirement on the presence or
absence of command line argument following the options.  Lastly, if it
is supplied and does not start with an open bracket, then option
processing must @strong{not} consume all of the command line arguments.

@cindex copyright
@item copyright

The @code{copyright} is a structured value containing three to five
values.  If @code{copyright} is used, then the first three are required.

@enumerate
@item
@file{date} - the list of applicable dates for the copyright.
@item
@file{owner} - the name of the copyright holder.
@item
@file{type} - specifies the type of distribution license.
AutoOpts/AutoGen will automatically support the text of the GNU Public
License (@file{GPL}), the GNU Public License with Library extensions
(@file{LGPL}), the Free BSD license (@file{BSD}), and a
write-it-yourself copyright notice (@file{NOTE}).  Only these values are
recognized.
@item
@file{text} - the text of the copyright notice.  It is only needed
if @file{type} is set to @file{NOTE}.
@item
@file{author} - in case the author name is to appear in the documentation
and is different from the copyright owner.
@end enumerate
@*
An example of this might be:
@example
copyright = @{
    date  = "1992-2001";
    owner = "Bruce Korb";
    type  = GPL;
@};
@end example

@cindex detail
@item detail
This string is added to the usage output when the HELP option is
selected.

@cindex environrc
@item environrc
Indicates looking in the environment for values of variables named
@*
PROGRAM_OPTNAME.
@*
where @code{PROGRAM} is the upper cased C-name of the program and
@code{OPTNAME} is the upper cased C-name of the option.  The
@code{C-name}s are the regular names with all special characters
converted to underscores (@code{_}).

If a particular option may be disabled, then its disabled state
is indicated by setting the value to the disablement prefix.
So, for example, if the disablement prefix were @code{dont}, then
you can disable the @code{optname} option by setting the
@code{PROGRAM_OPTNAME} environment variable to `@i{dont}'.
@xref{Optional Attributes}.

@cindex explain
@item explain
Gives additional information whenever the usage routine is invoked..

@cindex export
@item export
This string is inserted into the .h interface file.  Generally used for
global variables or @code{#include} directives required by
@code{flag_code} text and shared with other program text.

@cindex homerc
@item homerc
Specifies either a directory or a file using a specific path (like @code{.}
or @file{/usr/local/share/progname}) or an environment variable (like
@file{$HOME/rc/} or @file{$PREFIX/share/progname}) or the directory
where the executable was found (@file{$$[/...]}) to use to try to find
the rcfile.  Use as many as you like.  The presence of this attribute
activates the @code{SAVE_OPTS} and @code{LOAD_OPTS} options.
@xref{loading rc files}.

@cindex include
@item include
This string is inserted into the .c file.  Generally used for global
variables required only by @code{flag_code} program text.

@cindex long-opts
@item long-opts
Presence indicates GNU-standard long option processing.  If any options
do not have an option value (flag character) specified, and least one
does specify such a value, then you must specify @code{long-opts}.  If
none of your options specify an option value (flag character) and you do
not specify @code{long-opts}, then:

@itemize @bullet
@item
all program arguments are processed as named options
@item
the flag markers @code{-} and @code{--} are completely optional
@item
the @code{argument} program attribute is disallowed
@end itemize

@cindex prefix
@item prefix
This value is inserted into @strong{all} global names.  This will
disambiguate them if more than one set of options are to be compiled
into a single program.

@cindex rcfile
@item rcfile
Specifies the initialization file name.  This is only useful if you
have provided at least one @code{homerc} attribute.
@noindent
default: .<prog-name>rc

@cindex preserve-case
@item preserve-case
This attribute will not change anything except appearance.
Normally, the option names are all documented in lower case.
However, if you specify this attribute, then they will display
in the case used in their specification.  Command line options
will still be matched without case sensitivity.

@cindex test_main
@item test_main
Creates a test main procedure for testing option processing.  The
resulting program may also be used to process the arguments of a shell
script.  You would use it thus:

@example
eval `./programopts $@@`
if [ -z "$@{OPTION_CT@}" ] ; then exit 1 ; fi
shift $@{OPTION_CT@}
@end example

@cindex guile-main
@item guile-main
Creates a guile-style main and inner-main procedures.
The inner main procedure will call @code{optionProcess()} and will
invoke any code specified by this attribute.  If this attribute
does not specify any code, then calls to the AutoOpts library procedure
@code{export_options_to_guile()} and then @code{scm_shell()} will
be inserted into @code{inner_main()}.

@cindex before-guile-boot
@item before-guile-boot
If @code{guile-main} has been specified and if this is specified
as well, then this code will be inserted into the actual @code{main()}
procedure before @code{gh_enter()} is called.

@cindex rcsection
@item rcsection
If you have a collection of option descriptions that are intended
to use the same RC/ini files, then you will likely want to partition
that file.  That will be possible by specifying this attribute
with AutoOpts version 9.2 and later.

Every RC file will be considered partitioned by lines that commence with
the square open bracket (@code{[}).  All text before such a line is
always processed.  Once such a line is found, the @strong{upper-cased}
c-variable-syntax program name will be compared against the text
following that bracket.  If there is a match and the next character
after that is a square close bracket (@code{]}), then the section is
processed and the file closed.  Otherwise, the section is ignored and a
matching section is searched for.

For exampe, if the @code{foo-bar} options had a sectioned RC file,
then a line containing @code{[FOO_BAR]} would be searched for.

@cindex usage
@item usage
Optionally names the usage procedure, if the library routine
@code{optionUsage()} does not work for you.  If you specify
@code{gnu_usage} as the value of this attribute, for example,
you will use a procedure by that name for displaying usage.
Of course, you will need to provide that procedure.

@cindex version
@item version
Specifies the program version and activates the VERSION option.

@cindex automatic option flags
@item automatic option flags
If POSIX-style flag options are being used by an application,
then the flag characters for the automatically supported options
are normally selected by AutoOpts.  However, because you cannot
make a choice that everyone will accept, it is also possible to
specify the flag character to use.  The five automatic options,
the attribute to use to change the flag character, and the default
flag characters are:
@example
--help         help-value       -?
--more-help    more-help-value  -!
--version      version-value    -v
--save-opts    save-opts-value  ->
--load-opts    load-opts-value  -<
@end example
Note that some of these default characters are special to the shell.
Your users will need to quote them to use them.

If the @code{value} specified is empty, then the flag for that option
is disabled.  Otherwise, the value must be set to a single character.
@end table

@node option attributes
@subsection Option Attributes
@cindex option attributes

For each option you wish to specify, you must have a block macro named
@code{flag} defined.  It @strong{MUST} contain at least two defined text
values named @code{name} and @code{descrip}.  If any options do not have a
@code{value} macro, then the @code{long-opts} global text macro must be
defined.  As a special exception, if no options have a @code{value}
@strong{and} @code{long-opts} is not defined @strong{and} @code{argument} is
not defined, then all arguments to the program are named.  In this case, the
@code{-} and @code{--} command line option markers are optional.

There are four categories of option attributes.  The fifth section below
describes what data are available for writing option processing code.

@menu
* Required Attributes::         Required Attributes
* Optional Attributes::         Singly Optional Attributes
* Multiply Optional::           Multiply Optional Attributes
* Option Processing::           Special Option Processing
* Option Processing Data::      Data for Option Processing
@end menu

@node Required Attributes
@subsubsection Required Attributes
@cindex Required Attributes

Every option must have exactly one copy of both of these attributes.

@table @samp
@cindex name
@item name
Long name for the option.  Even if you are not accepting long options
and are only accepting flags, it must be provided.  AutoOpts generates
private, named storage that require this name.

@cindex descrip
@item descrip
Except for documentation options, a @strong{very} brief description
of the option.  About 40 characters on one line, maximum.
It appears on the @code{usage()} output next to the option name.
Documentation options appear on one or more lines by themselves,
visually separating the usage options.
@end table

@node Optional Attributes
@subsubsection Singly Optional Attributes
@cindex Optional Attributes

These option attributes are optional.  Any that do appear in the
definition of a flag, may appear only once.

@table @samp
@cindex documentation
@item documentation
If present, disables all other attributes except @code{settable},
@code{call_proc} and @code{flag_code}.  @code{settable} must be and is
only specified if @code{call_proc} or @code{flag_code} has been specified.
When present, the @code{descrip} attribute will be displayed only
when the @code{--help} option has been specified.  It will be displayed
flush to the left hand margin and may consist of one or more lines
of text.  The name of the option will not be printed.

The option may be made settable if, for example, you are supplying
options to a client program.  In that fashion, your handler routine for
the documentation option can save the address of the program descriptor
and your first option (@code{prog_desc} and @code{opts_ptr}) in global
pointers.

@cindex value
@item value
The flag character to specify for traditional option flags.  e.g. @code{-L}.

@cindex arg_type
@item arg_type
This specifies the type of argument the option will take.
If not present, the option cannot take an argument.
If present, it must be one of the following four.
The bracketed part of the name is optional.

@table @samp
@item str[@i{ing}]
The argument may be any arbitrary string.

@item num[@i{ber}]
The argument must be a correctly formed number, without any trailing
U's or L's.

@item bool[@i{ean}]
The argument will be interpreted and always yield either AG_TRUE or
AG_FALSE.  False values are@:  the empty string, the number zero, or a
string that starts with @code{f}, @code{F}, @code{n} or @code{N}
(representing False or No).  Anything else will be interpreted as True.

@item key[@i{word}]
The argument must match a specified list of strings.
Assuming you have named the option, @code{opt-name},
the strings will be converted into an enumeration of type @code{te_Opt_Name}
with the values @code{OPT_NAME_KEYWORD}.  If you have @strong{not}
specified a default value, the value @code{OPT_NAME_UNDEFINED} will be
inserted with the value zero.  The option will be initialized to that
value.  You may now use this in your code as follows:

@smallexample
te_Opt_Name opt = OPT_VALUE_OPT_NAME;
switch (opt) @{
case OPT_NAME_UNDEFINED:  /* undefined things */ break;
case OPT_NAME_KEYWORD:    /* `keyword' things */ break;
default: /* utterly impossible */ ;
@}
@end smallexample
@end table

@cindex arg_optional
@item arg_optional
This attribute indicates that the user does not have to supply an
argument for the option.  This is only valid if the @var{arg_type} is
@code{string} or @code{keyword}.  If it is @code{keyword}, then
this attribute may also specify the default keyword to assume when
the argument is not supplied.  Without such a specification, the
default keyword will be the zero-valued keyword.

@cindex arg_default
@item arg_default
This specifies the default value to be used when the option is
not specified or preset.

@cindex min
@item min
Minimum occurrence count.  If present, then the option @strong{must}
appear on the command line.  Preset values do not count towards the
minimum occurrence count.

@cindex max
@item max
Maximum occurrence count (invalid if @var{disable} present).

@cindex enable
@item enable
Long-name prefix for enabling the option (invalid if @var{disable}
@strong{not} present).

@cindex disable
@item disable
Prefix for disabling (inverting sense of) the option.

@cindex enabled
@item enabled
If default is for option being enabled.  (Otherwise, the OPTST_DISABLED
bit is set at compile time.)

@item ifdef
@itemx ifndef
If an option is relevant on certain platforms or when certain features
are enabled or disabled, you can specify the compile time flag used
to indicate when the option should be compiled in or out.  For example,
if you have a configurable feature, @code{mumble} that is indicated
with the compile time define, @code{WITH_MUMBLING}, then add:

@example
ifdef = WITH_MUMBLING;
@end example

@noindent
Note that case and spelling must match whatever you are using.

@cindex no_preset
@item no_preset
If presetting this option is not allowed.  (Thus, environment variables
and values set in rc/ini files will be ignored.)

@cindex settable
@item settable
If the option can be set outside of option processing.  If this
attribute is defined, special macros for setting this particular option
will be inserted into the interface file.  For example,
@code{TEMPL_DIRS} is a settable option for AutoGen, so a macro named
@code{SET_OPT_TEMPL_DIRS(a)} appears in the interface file.  This
attribute interacts with the @var{documentation} attribute.

@cindex equivalence
@item equivalence
Generally, when several options are mutually exclusive and basically serve
the purpose of selecting one of several processing modes, these options
can be considered an equivalence class.  Sometimes, it is just easier to
deal with them as such.

For an option equivalence class, there is a single occurrence counter
for all the members of the class.  All members of the equivalence class
must contain the same equivalenced-to option, including the
equivalenced-to option itself.  Thus, it must be a member.

As an example, @code{cpio(1)} has three options @code{-o}, @code{-i},
and @code{-p} that define the operational mode of the program
(@code{create}, @code{extract} and @code{pass-through}, respectively).
They form an equivalence class from which one and only one member must
appear on the command line.  If @code{cpio} were an AutoOpt-ed program,
then each of these option definitions would contain:

@example
equivalence = create;
@end example

and the program would be able to determine the operating mode
with code that worked something like this:

@example
switch (WHICH_IDX_CREATE) @{
case INDEX_OPT_CREATE:       ...
case INDEX_OPT_EXTRACT:      ...
case INDEX_OPT_PASS_THROUGH: ...
default:    /* cannot happen */
@}
@end example

@cindex default
@item default
If your program processes its arguments in named-option mode, then you
may select @strong{one} of your options to be the default option.  That
option must have a required option argument.

If you have done this, then any arguments that do not match an option
name and do not contain an equal sign (@code{=}) will be interpreted as
option arguments to the default option.
@end table

@node Multiply Optional
@subsubsection Multiply Optional Attributes
@cindex Multiply Optional

These attributes may be used as many times as you need.
They are used at the end of the option processing to verify
that the context within which each option is found does not
conflict with the presence or absence of other options.

This is not a complete cover of all possible conflicts and
requirements, but it simple to implement and covers the
more common situations.

@table @samp
@cindex flags_must
@item flags_must
one entry for every option that @strong{must} be present
when this option is present

@cindex flags_cant
@item flags_cant
one entry for every option that @strong{cannot} be present
when this option is present
@end table

@node Option Processing
@subsubsection Special Option Processing
@cindex Option Processing

The first two attributes interact with the @code{documentation} and
@code{settable} attributes.  See their documentation above.

Pick zero or one of the next four:

@table @samp
@cindex flag_code
@item flag_code
statements to execute when the option is encountered.
The generated procedure will look like this:

@example
static void
doOpt<name>( tOptions* pOptions, tOptDesc* pOptDesc )
@{
<flag_code>
@}
@end example

Only certain fields within the @code{tOptions} and @code{tOptDesc}
structures may be accessed.  @xref{Option Processing Data}.

@cindex extract_code
@item extract_code
This is effectively identical to @code{flag_code}, except that the
source is kept in the output file instead of the definitions file.
A long comment is used to demarcate the code.  You must not modify
that marker.  @i{Before} regenerating the option code file, you must
rename the old file from MUMBLE.c to MUMBLE.c.save.  The template
will be looking there for the text to copy into the new output file.

@cindex call_proc
@item call_proc
external procedure to call when option is encountered.  The calling
sequence must conform to the sequence defined above for the generated
procedure, @code{doOpt<name>}.  It has the same restrictions
regarding the fields within the structures passed in as arguments.
@xref{Option Processing Data}.

@cindex flag_proc
@item flag_proc
Name of another option whose @code{flag_code} can be executed
when this option is encountered.

@cindex stack_arg
@item stack_arg
Call a special library routine to stack the option's arguments.  Special
macros in the interface file are provided for determining how many of
the options were found (@code{STACKCT_OPT(NAME)}) and to obtain a
pointer to a list of pointers to the argument values
(@code{STACKLST_OPT(NAME)}).
@end table

@node Option Processing Data
@subsubsection Data for Option Processing
@cindex Option Processing Data

The following fields may be used in the following ways and may be used
for read only.  The first set is addressed from the @code{tOptDesc*}
pointer:

@table @samp
@cindex optIndex
@item optIndex
@cindex optValue
@item optValue
These may be used by option procedures to determine which option they
are working on (in case they handle several options).

@cindex optActualIndex
@item optActualIndex
@cindex optActualValue
@item optActualValue
These may be used by option procedures to determine which option was
used to set the current option.  This may be different from the above if
the options are members of an equivalence class.

@cindex optOccCt
@item optOccCt
If AutoOpts is processing command line arguments, then this value will
contain the current occurrence count.  During the option preset phase
(reading rc/ini files and examining environment variables), the value is
zero.

@cindex fOptState
@item fOptState
The field may be tested for the following bit values
(prefix each name with @code{OPTST_}, e.g. @code{OPTST_INIT}):

@table @samp
@item INIT
Initial compiled value.  As a bit test, it will always yield FALSE.

@item SET
The option was set via the @code{SET_OPT()} macro.

@item PRESET
The option was set via an RC/INI file, or a call to the
@code{optionLoadLine()} routine.

@item DEFINED
The option was set via a command line option.

@item SET_MASK
This is a mask of flags that show the set state, one of the
above four values.

@item EQUIVALENCE
This bit is set when the option was selected by an equivalenced option.

@item DISABLED
This bit is set if the option is to be disabled.
(Meaning it was a long option prefixed by the disablement prefix, or
the option has not been specified yet and initializes as @code{disabled}.)
@end table

As an example of how this might be used, in AutoGen I want to allow
template writers to specify that the template output can be left
in a writable or read-only state.  To support this, there is a Guile
function named @code{set-writable} (@pxref{SCM set-writable}).
Also, I provide for command options @code{--writable} and
@code{--not-writable}.  I give precedence to command line and RC
file options, thus:

@example
switch (STATE_OPT( WRITABLE )) @{
case OPTST_DEFINED:
case OPTST_PRESET:
    fprintf( stderr, zOverrideWarn, pCurTemplate->pzFileName,
             pCurMacro->lineNo );
    break;

default:
    if (gh_boolean_p( set ) && (set == SCM_BOOL_F))
        CLEAR_OPT( WRITABLE );
    else
        SET_OPT_WRITABLE;
@}
@end example

@cindex pzLastArg
@item pzLastArg
Pointer to the latest argument string.  BEWARE@:  If the argument type is
numeric or an enumeration, then this will be the argument @strong{value} and
not a pointer to a string.
@end table

The following two fields are addressed from the @code{tOptions*} pointer:

@table @samp
@cindex pzProgName
@item pzProgName
Points to a NUL-terminated string containing the current program
name, as retrieved from the argument vector.

@cindex pzProgPath
@item pzProgPath
Points to a NUL-terminated string containing the full path of
the current program, as retrieved from the argument vector.
(If available on your system.)

@end table

Note@:  these fields get filled in during the first call to
@code{optionProcess()}.  All other fields are private, for the exclusive
use of AutoOpts code and is subject to change.

@node documentation attributes
@subsection Man and Info doc Attributes
@cindex documentation attributes

AutoOpts includes AutoGen templates for producing abbreviated man pages
and for producing the invoking section of an info document.  To take
advantage of these templates, you must add several attributes to your
option definitions.

@cindex doc
First, every @code{flag} definition must have a @code{doc} attribute
defined and many will need an @code{arg_name} attribute as well.  The
@code{doc} text should be in plain sentences with minimal formatting.  The
Texinfo commands @code{@@code}, and @code{@@var} will have its enclosed
text made into @strong{\fB} entries in the man page, and the @code{@@file}
text will be made into @strong{\fI} entries.  The @code{arg_name} attribute
is used to display the option's argument in the man page.

@cindex detail
@cindex prog_man_descrip
@cindex prog_info_descrip
Then, you need to supply a brief description of what your program does.
If you already have a @code{detail} definition, this may be sufficient.
If not, or if you need special formatting for one of the manual formats,
then you will need either a definition for @code{prog_man_descrip} or
@code{prog_info_descrip} or both.  These will be inserted verbatim
in the man page document and the info document, respectively.

@cindex man_doc
Finally, if you need to add man page sections like @code{SEE ALSO} or
@code{USAGE} or other, put that text in a @code{man_doc} definition.  This
text will be inserted verbatim in the man page after the @code{OPTIONS}
section and before the @code{AUTHOR} section.

@node immediate action
@subsection Immediate Action Attributes
@cindex immediate action

Certain options may need to be processed early.  For example, in order
to suppress the processing of RC files, it is necessary to process the
command line option @code{--no-load-opts} @strong{before} the RC files
are processed.  To accommodate this, certain options may have their
enabled or disabled forms marked for immediate processing.  The
consequence of this is that they are processed ahead of all other
options in the reverse of normal order.

Normally, the first options processed are the options specified in the
first @code{homerc} file, followed by then next @code{homerc} file
through to the end of RC file processing.  Next, environment variables
are processed and finally, the command line options.  The later
options override settings processed earlier.  That actually gives them
higher priority.  Command line immediate action options actually have
the lowest priority of all.  They would be used only if they are to have
an effect on the processing of subsequent options.

@table @samp
@cindex immediate
@item immediate
Use this option attribute to specify that the enabled form of the option
is to be processed immediately.  The @code{help} and @code{more-help}
options are so specified.  They will also call @code{exit()} upon
completion, so they @strong{do} have an effect on the processing
of the remaining options :-).

@cindex immed_disable
@item immed_disable
Use this option attribute to specify that the disabled form of the option
is to be processed immediately.  The @code{load-opts} option is so
specified so that the @code{--no-load-opts} command line option will
suppress the processing of RC files and environment variables.
@end table

@node standard options
@subsection Automatically Supported Options
@cindex standard options

AutoOpts provides automated support for five options.  @code{help} and
@code{more-help} are always provided.  @code{version} is provided if
@code{version} is defined in the option definitions.  @code{save-opts}
and @code{load-opts} are provided if at least one @code{homerc} is
defined.

Below are the option names and flag values.  The flags are activated if
and only if at least one user-defined option also uses a flag value.
They may be changed to characters of your choosing by specifying
the program options @code{mumble-value = 'x';}, where @code{mumble} is
one of the names below and @code{x} is the character of your choice.

@table @samp
@item help -?
This option will immediately invoke the @code{USAGE()} procedure
and display the usage line, a description of each option with
its description and option usage information.  This is followed
by the contents of the definition of the @code{detail} text macro.

@item more-help -!
This option is identical to the @code{help} option, except that
it also includes the contents of the @code{detail-file} file
(if provided and found), plus the output is passed through
a pager program.  (@code{more} by default, or the program identified
by the @code{PAGER} environment variable.)

@item version -v
This will print the program name, title and version.
If it is followed by the letter @code{c} and
a value for @code{copyright} and @code{owner} have been provided,
then the copyright will be printed, too.
If it is followed by the letter @code{n}, then the full
copyright notice (if available) will be printed.

@item save-opts ->
This option will cause the option state to be printed in
RC/INI file format when option processing is done but not
yet verified for consistency.  The program will terminate
successfully without running when this has completed.
Note that for most shells you will have to quote or escape the
flag character to restrict special meanings to the shell.

The output file will be the RC/INI file name (default or provided
by @code{rcfile}) in the last directory named in a @code{homerc}
definition

@item load-opts -<
This option will load options from the named file.  They
will be treated exactly as if they were loaded from the
normally found RC/INI files, but will not be loaded until
the option is actually processed.  This can also be used
within an RC/INI file causing them to nest.

It is ultimately intended that specifying the option,
@code{no-load-opts} will suppress the processing of rc/ini files and
environment variables.  To do this, AutoOpts must first implement
pre-scanning of the options, environment and rc files.
@end table

@node AutoOpts API
@section Programmatic Interface
@cindex AutoOpts API

The user interface for access to the argument information is completely
defined in the generated header file and in the portions of the
distributed file "options.h" that are marked "public".

In the following macros, text marked @code{<OPT_NAME>} or @code{optname}
is the name of the option @strong{in upper case} and @strong{segmented
with underscores @code{_}}.  The macros and enumerations defined in the
options header (interface) file are used as follows:

To see how these @code{#define} macros are used in a program,
the reader is referred to the several @file{opts.h} files
included with the AutoGen sources.

@menu
* CLEAR_OPT::               CLEAR_OPT( <NAME> ) - Clear Option Markings
* COUNT_OPT::               COUNT_OPT( <NAME> ) - Definition Count
* DESC::                    DESC( <NAME> ) - Option Descriptor
* DISABLE_OPT_name::        DISABLE_OPT_name - Disable an option
* ENABLED::                 ENABLED( <NAME> ) - Is Option Enabled?
* ERRSKIP_OPTERR::          ERRSKIP_OPTERR - Ignore Option Errors
* ERRSTOP_OPTERR::          ERRSTOP_OPTERR - Stop on Errors
* HAVE_OPT::                HAVE_OPT( <NAME> ) - Have this option?
* ISSEL_OPT::               ISSEL_OPT( <NAME> ) - Is Option Selected?
* ISUNUSED_OPT::            ISUNUSED_OPT( <NAME> ) - Never Specified?
* OPTION_CT::               OPTION_CT - Full Count of Options
* OPT_ARG::                 OPT_ARG( <NAME> ) - Option Argument String
* OPT_VALUE_name::          OPT_VALUE_name - Option Argument Value
* RESTART_OPT::             RESTART_OPT( n ) - Resume Option Processing
* SET_OPT_name::            SET_OPT_name - Force an option to be set
* STACKCT_OPT::             STACKCT_OPT( <NAME> ) - Stacked Arg Count
* STACKLST_OPT::            STACKLST_OPT( <NAME> ) - Argument Stack
* START_OPT::               START_OPT - Restart Option Processing
* STATE_OPT::               STATE_OPT( <NAME> ) - Option State
* USAGE::                   USAGE( exit-code ) - Usage invocation macro
* VALUE_OPT_name::          VALUE_OPT_name - Option Flag Value
* VERSION::                 VERSION - Version and Full Version
* WHICH_IDX_name::          WHICH_IDX_name - Which Equivalenced Index
* WHICH_OPT_name::          WHICH_OPT_name - Which Equivalenced Option
* teOptIndex::              teOptIndex - Option Index and Enumeration
* OPTIONS_STRUCT_VERSION::  OPTIONS_STRUCT_VERSION - active version
* libopts procedures::      libopts Procedures
@end menu

@node CLEAR_OPT
@subsection CLEAR_OPT( <NAME> ) - Clear Option Markings
@findex CLEAR_OPT

Make as if the option had never been specified.
@code{HAVE_OPT(<NAME>)} will yield @code{FALSE}
after invoking this macro.

@node COUNT_OPT
@subsection COUNT_OPT( <NAME> ) - Definition Count
@findex COUNT_OPT

This macro will tell you how many times the option was
specified on the command line.  It does not include counts
of preset options.

@example
if (COUNT_OPT( NAME ) != desired-count) @{
    make-an-undesirable-message.
@}
@end example

@node DESC
@subsection DESC( <NAME> ) - Option Descriptor
@findex DESC

This macro is used internally by other AutoOpt macros.
It is not for general use.  It is used to obtain the option description
corresponding to its @strong{UPPER CASED} option name argument.
This is primarily used in other macro definitions.

@node DISABLE_OPT_name
@subsection DISABLE_OPT_name - Disable an option
@findex DISABLE_OPT_name

This macro is emitted if it is both settable
and it can be disabled.  If it cannot be disabled, it may
always be CLEAR-ed (see above).

The form of the macro will actually depend on whether the
option is equivalenced to another, and/or has an assigned
handler procedure.  Unlike the @code{SET_OPT} macro,
this macro does not allow an option argument.

@example
DISABLE_OPT_NAME;
@end example

@node ENABLED
@subsection ENABLED( <NAME> ) - Is Option Enabled?
@findex ENABLED

Yields true if the option defaults to disabled and
@code{ISUNUSED_OPT()} would yield true.  It also yields true if
the option has been specified with a disablement prefix,
disablement value or the @code{DISABLE_OPT_NAME} macro was invoked.

@node ERRSKIP_OPTERR
@subsection ERRSKIP_OPTERR - Ignore Option Errors
@findex ERRSKIP_OPTERR

When it is necessary to continue (return to caller)
on option errors, invoke this option.  It is reversible.
@xref{ERRSTOP_OPTERR}.

@node ERRSTOP_OPTERR
@subsection ERRSTOP_OPTERR - Stop on Errors
@findex ERRSTOP_OPTERR

After invoking this macro, if @code{optionProcess()}
encounters an error, it will call @code{exit(1)} rather than return.
This is the default processing mode.  It can be overridden by
specifying @code{allow_errors} in the definitions file,
or invoking the macro @xref{ERRSKIP_OPTERR}.

@node HAVE_OPT
@subsection HAVE_OPT( <NAME> ) - Have this option?
@findex HAVE_OPT

This macro yields true if the option has been specified
in any fashion at all.  It is used thus:

@example
if (HAVE_OPT( NAME )) @{
    <do-things-associated-with-opt-name>;
@}
@end example

@node ISSEL_OPT
@subsection ISSEL_OPT( <NAME> ) - Is Option Selected?
@findex ISSEL_OPT

This macro yields true if the option has been
specified either on the command line or via a SET/DISABLE macro.

@node ISUNUSED_OPT
@subsection ISUNUSED_OPT( <NAME> ) - Never Specified?
@findex ISUNUSED_OPT

This macro yields true if the option has
never been specified, or has been cleared via the
@code{CLEAR_OPT()} macro.

@node OPTION_CT
@subsection OPTION_CT - Full Count of Options
@findex OPTION_CT

The full count of all options, both those defined
and those generated automatically by AutoOpts.  This is primarily
used to initialize the program option descriptor structure.

@node OPT_ARG
@subsection OPT_ARG( <NAME> ) - Option Argument String
@findex OPT_ARG

The option argument value as a pointer to string.  Note that argument
values that have been specified as numbers are stored as numbers or
keywords.  For such options, use instead the @code{OPT_VALUE_name}
define.  It is used thus:

@example
if (HAVE_OPT( NAME )) @{
    char* p = OPT_ARG( NAME );
    <do-things-with-opt-name-argument-string>;
@}
@end example

@node OPT_VALUE_name
@subsection OPT_VALUE_name - Option Argument Value
@findex OPT_VALUE_name

This macro gets emitted only for options that take numeric or keyword
arguments.  The macro yields a word-sized integer containing the
enumeration or numeric value of the option argument.

@example
int opt_val = OPT_VALUE_NAME;
@end example

@node RESTART_OPT
@subsection RESTART_OPT( n ) - Resume Option Processing
@findex RESTART_OPT

If option processing has stopped (either because of an error
or something was encountered that looked like a program argument),
it can be resumed by providing this macro with the index @code{n}
of the next option to process and calling @code{optionProcess()} again.

@node SET_OPT_name
@subsection SET_OPT_name - Force an option to be set
@findex SET_OPT_name

This macro gets emitted only when the given
option has the @code{settable} attribute specified.

The form of the macro will actually depend on whether the option is
equivalenced to another, has an option argument and/or has an assigned
handler procedure.  If the option has an argument, then this macro will
too.  Beware that the argument is not reallocated, so the value must not
be on the stack or deallocated in any other way for as long as the value
might get referenced.

@example
SET_OPT_NAME( "string-value" );
@end example

@node STACKCT_OPT
@subsection STACKCT_OPT( <NAME> ) - Stacked Arg Count
@findex STACKCT_OPT

When the option handling attribute is specified
as @code{stack_arg}, this macro may be used to determine how
many of them actually got stacked.

Do not use this on options that have not been stacked or has not been
specified (the @code{stack_arg} attribute must have been specified,
and @code{HAVE_OPT(<NAME>)} must yield TRUE).
Otherwise, you will likely page fault.

@example
if (HAVE_OPT( NAME )) @{
    int     ct = STACKCT_OPT(  NAME );
    char**  pp = STACKLST_OPT( NAME );

    do  @{
        char* p = *pp++;
        do-things-with-p;
    @} while (--ct > 0);
@}
@end example

@node STACKLST_OPT
@subsection STACKLST_OPT( <NAME> ) - Argument Stack
@findex STACKLST_OPT

The address of the list of pointers to the
option arguments.  The pointers are ordered by the order in
which they were encountered in the option presets and
command line processing.

Do not use this on options that have not been stacked or has not been
specified (the @code{stack_arg} attribute must have been specified,
and @code{HAVE_OPT(<OPTION>)} must yield TRUE).
Otherwise, you will likely page fault.

@example
if (HAVE_OPT( NAME )) @{
    int     ct = STACKCT_OPT(  NAME );
    char**  pp = STACKLST_OPT( NAME );

    do  @{
        char* p = *pp++;
        do-things-with-p;
    @} while (--ct > 0);
@}
@end example

@node START_OPT
@subsection START_OPT - Restart Option Processing
@findex START_OPT

This is just a shortcut for RESTART_OPT(1) (@xref{RESTART_OPT}.)

@node STATE_OPT
@subsection STATE_OPT( <NAME> ) - Option State
@findex STATE_OPT

If you need to know if an option was set because of
presetting actions (RC/INI processing or environment variables),
versus a command line entry versus one of the SET/DISABLE macros,
then use this macro.  It will yield one of four values:
@code{OPTST_INIT}, @code{OPTST_SET}, @code{OPTST_PRESET}
or @code{OPTST_DEFINED}.  It is used thus:

@example
switch (STATE_OPT( NAME )) @{
    case OPTST_INIT:
        not-preset, set or on the command line.  (unless CLEAR-ed)

    case OPTST_SET:
        option set via the SET_OPT_NAME() macro.

    case OPTST_PRESET:
        option set via an RC/INI file or environment variable

    case OPTST_DEFINED:
        option set via a command line option.

    default:
        cannot happen :)
@}
@end example

@node USAGE
@subsection USAGE( exit-code ) - Usage invocation macro
@findex USAGE

This macro invokes the procedure registered to display
the usage text.  Normally, this will be @code{optionUsage} from the
AutoOpts library, but you may select another procedure by specifying
@code{usage = "proc_name"} program attribute.  This procedure must
take two arguments@:  first, a pointer to the option descriptor, and
second the exit code.  The macro supplies the option descriptor
automatically.  This routine is expected to call @code{exit(3)} with
the provided exit code.

The @code{optionUsage} routine also behaves differently depending
on the exit code.  If the exit code is zero, it is assumed that
assistance has been requested.  Consequently, a little more
information is provided than when displaying usage and exiting
with a non-zero exit code.

@node VALUE_OPT_name
@subsection VALUE_OPT_name - Option Flag Value
@findex VALUE_OPT_name

This is a #define for the flag character used to
specify an option on the command line.  If @code{value} was not
specified for the option, then it is a unique number associated
with the option.  @code{option value} refers to this value,
@code{option argument} refers to the (optional) argument to the
option.

@example
switch (WHICH_OPT_OTHER_OPT) @{
case VALUE_OPT_NAME:
    this-option-was-really-opt-name;
case VALUE_OPT_OTHER_OPT:
    this-option-was-really-other-opt;
@}
@end example

@node VERSION
@subsection VERSION - Version and Full Version
@findex VERSION

If the @code{version} attribute is defined for the program,
then a stringified version will be #defined as PROGRAM_VERSION and
PROGRAM_FULL_VERSION.  PROGRAM_FULL_VERSION is used for printing
the program version in response to the version option.  The version
option is automatically supplied in response to this attribute, too.

You may access PROGRAM_VERSION via @code{programOptions.pzFullVersion}.

@node WHICH_IDX_name
@subsection WHICH_IDX_name - Which Equivalenced Index
@findex WHICH_IDX_name

This macro gets emitted only for equivalenced-to options.  It is used to
obtain the index for the one of the several equivalence class members
set the equivalenced-to option.

@example
switch (WHICH_IDX_OTHER_OPT) @{
case INDEX_OPT_NAME:
    this-option-was-really-opt-name;
case INDEX_OPT_OTHER_OPT:
    this-option-was-really-other-opt;
@}
@end example

@node WHICH_OPT_name
@subsection WHICH_OPT_name - Which Equivalenced Option
@findex WHICH_OPT_name

This macro gets emitted only for equivalenced-to options.  It is used to
obtain the value code for the one of the several equivalence class members
set the equivalenced-to option.

@example
switch (WHICH_OPT_OTHER_OPT) @{
case VALUE_OPT_NAME:
    this-option-was-really-opt-name;
case VALUE_OPT_OTHER_OPT:
    this-option-was-really-other-opt;
@}
@end example

@node teOptIndex
@subsection teOptIndex - Option Index and Enumeration
@findex teOptIndex

This enum defines the complete set of options, both
user specified and automatically provided.  This can be used,
for example, to distinguish which of the equivalenced options
was actually used.

@example
switch (pOptDesc->optActualIndex) @{
case INDEX_OPT_FIRST:
    stuff;
case INDEX_OPT_DIFFERENT:
    different-stuff;
default:
    unknown-things;
@}
@end example

@node OPTIONS_STRUCT_VERSION
@subsection OPTIONS_STRUCT_VERSION - active version

You will not actually need to reference this value, but you need to be
aware that it is there.  It is the first value in the option descriptor
that you pass to @code{optionProcess}.  It contains a magic number and
version information.  Normally, you should be able to work with a more
recent option library than the one you compiled with.  However, if the
library is changed incompatibly, then the library will detect the out of
date magic marker, explain the difficulty and exit.  You will then need
to rebuild and recompile your option definitions.  This has rarely been
necessary.

@node libopts procedures
@subsection libopts procedures

These are the publicly exported procedures from the libopts library.

@table @samp
@item optionProcess
This is the main entry point for processing options.  It is intended
that this procedure be called once at the beginning of the execution of
a program.  Depending on options selected earlier, it is sometimes
necessary to stop and restart option processing, or to select completely
different sets of options.  This can be done easily, but you generally
do not want to do this.

@item optionVersion
Returns the full version string compiled into the library.

@item optionLoadLine
When passed a pointer to the option struct and a string, it will
find the option named by the first token on the string and set
the option argument to the remainder of the string.  The caller must
NUL terminate the string.  Any embedded new lines will be included
in the option argument.

@item putBourneShell
This routine will write to stdout the state of the options as encoded
in the option structure.  It will also write out the number of arguments
consumed by option processing.  The output result can be eval-ed by
a shell in the following manner:

@smallexample
eval "`handle-prog-opts $@{1+\"$@@\"@}`"
[ -z "$OPTION_CT" ] && exit 1
shift $OPTION_CT
@end smallexample

@noindent
This routine is normally specified by specifying
@code{test-main = yes;} in the option definitions file.

@item putShellParse
This routine will write to stdout a series of shell commands that
will parse the command line options.  This routine will be called
when you specify @code{test-main = putShellParse;} and the result
is compiled with @code{-DTEST_xxx_OPTS} defined.  This is the
only way it should ever be invoked.

@item all the rest
The remaining routines are for the exclusive use of the generated
option processing code.  You should not be using them directly.
@end table

@node option descriptor
@section Option Descriptor File
@cindex option descriptor

This is the module that is to be compiled and linked with your program.
It contains internal data and procedures subject to change.  Basically,
it contains a single global data structure containing all the
information provided in the option definitions, plus a number of static
strings and any callout procedures that are specified or required.  You
should never have need for looking at this, except, perhaps, to examine
the code generated for implementing the @code{flag_code} construct.

@node Using AutoOpts
@section Using AutoOpts
@cindex using AutoOpts

To use AutoOpts in your application:

@itemize @bullet
@item
Create a file @samp{myopts.def}, according to the documentation above.
It is probably easiest to start with the example in @ref{Quick Start}
and edit it into the form you need.

@item
Run AutoGen to create the option interface file (@code{myopts.h})
and the option descriptor code (@code{myopts.c}):

@example
autogen -L $prefix/share/autogen myopts.def
@end example

@item
In all your source files where you need to refer to option state,
@code{#include "myopts.h"}.
@item
In your main routine, code something along the lines of:

@example
main( int argc, char** argv )
@{
    @{
        int arg_ct = optionProcess( &myprogOptions, argc, argv );
        argc -= arg_ct;
        if ((argc < ARGC_MIN) || (argc > ARGC_MAX)) @{
            fprintf( stderr, "%s ERROR:  remaining args (%d) "
                     "out of range\n", myprogOptions.pzProgName,
                     argc );

            USAGE( EXIT_FAILURE );
        @}
        argv += arg_ct;
    @}
    if (HAVE_OPT(OPT_NAME))
        respond_to_opt_name();
    ...
@}
@end example

@item
Compile @samp{myopts.c} and link your program
with the following additional arguments:

@example
myopts.o -L $prefix/lib -lopts
@end example
@end itemize

@node shell options
@section AutoOpts for Shell Scripts
@cindex shell options

AutoOpts may be used with shell scripts by automatically creating a
complete program that will process command line options and pass back
the results to the invoking shell by issuing shell variable assignment
commands.  It may also be used to generate portable shell code that can
be inserted into your script.

The functionality of these features, of course, is somewhat constrained
compared with the normal program facilities.  Specifically, you cannot
invoke callout procedures with either of these methods.  Additionally,
if you generate a shell script:

@enumerate
@item
You cannot obtain options from RC/INI files.
@item
You cannot obtain options from environment variables.
@item
You cannot save the option state to an option file.
@item
Option conflict/requirement verification is disabled.
@end enumerate

Both of these methods are enabled by running AutoGen on
the definitions file with the additional global attribute:

@example
test_main [ = proc-to-call ] ;
@end example

If you do not supply a @code{proc-to-call}, it will default
to @code{putBourneShell}.  That will produce a program that
will process the options and generate shell text for the
invoking shell to interpret.  If you supply the name,
@code{putShellParse}, then you will have a program that
will generate a shell script that can parse the options.
If you supply a different procedure name, you will have to
provide that routine and it may do whatever you like.

In summary, you will need to issue approximately the
following two commands to have a working program:

@example
autogen -L <opt-template-dir> program.def
cc -o progopts -L <opt-lib-dir> -I <opt-include-dir> \
        -DTEST_program_OPTS program.c -lopts
@end example

The resulting
program can be used within your shell script as follows:

@example
eval `./progopts $@@`
if [ -z "$@{OPTION_CT@}" ] ; then exit 1 ; fi
shift $@{OPTION_CT@}
@end example

If you had used @code{-DTEST_MAIN=putShellParse} instead, then you can,
at this point, merely run the program and it will write the parsing
script to standard out.  You may also provide this program with command
line options to specify the shell script file to create or edit, and you
may specify the shell program to use on the first shell script line.
That program's usage text would look something like this:

@ignore
END   == AUTOOPTS == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == AUTOINFO == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@node AutoInfo
@section Automated @samp{Invoking Info} Doc
@cindex AutoInfo

Using the option definitions for an AutoOpt client program, the
@file{aginfo.tpl} template will produce texinfo text that documents the
invocation of your program.  The text emitted is designed to be included
in the full texinfo document for your product.  It is not a
stand-alone document.  The usage text included in this document for the
@file{autogen}, @file{getdefs} and @file{columns} programs is all
generated using this template.

Two files will be produced, a @file{.texi} file and a @file{.menu} file.
You should include the @file{.menu} file in your document where you wish
to reference the @samp{invoking} chapter, section or subsection.  The
documentation level is selected by passing a @samp{-DLEVEL=<level-name>}
argument to AutoGen when you build the document.  (See the example
invocation below.)

The @file{.texi} file will contain an introductory paragraph, a menu
and a subordinate section for the invocation usage and for each
documented option.  The introductory paragraph is normally the boiler
plate text:

@example
This chapter documents the @@file@{AutoOpts@} generated usage text
and option meanings for the @@file@{your-program@} program.
@end example

@noindent
However, if your program's option definitions include a
@samp{prog_info_descrip} section, then that is what will be used instead.

These files are produced by invoking the following command:

@example
AutoGen -L $@{prefix@}/share/autogen -T aginfo.tpl \
        -DLEVEL=section your-opts.def
@end example

@noindent
Where @file{$@{prefix@}} is the AutoGen installation prefix
and @file{your-opts.def} is the name of your product's option
definition file.

@node AutoMan pages
@section Automated Man Pages
@cindex AutoMan pages

Using the option definitions for an AutoOpt client program,
the @samp{agman1.tpl} template will produce an nroff document
suitable for use as a @samp{man(1)} page document for a command
line command.  The description section of the document is either
the @samp{prog_man_descrip} text, if present, or the @samp{detail}
text.

Each option in the option definitions file is fully documented
in its usage.  This includes all the information documented
above for each option (@pxref{option attributes}), plus
the @samp{doc} attribute is appended.  Since the @samp{doc}
text is presumed to be designed for @code{texinfo} documentation,
@code{sed} is used to convert some constructs from @code{texi}
to @code{nroff}-for-@code{man}-pages.  Specifically,

@example
convert @@code, @@var and @@samp into \fB...\fP phrases
convert @@file into \fI...\fP phrases
Remove the '@@' prefix from curly braces
Indent example regions
Delete the example commands
Replace @samp{end example} command with ".br"
Replace the @samp{@@*} command with ".br"
@end example

@noindent
This document is produced by invoking the following command:

@example
AutoGen -L $@{prefix@}/share/autogen -T agman1.tpl options.def
@end example

@noindent
Where @file{$@{prefix@}} is the AutoGen installation prefix and
@file{options.def} is the name of your product's option definition file.
I do not use this very much, so any feedback or improvements would be
greatly appreciated.

@page
@node Add-Ons
@chapter Add-on packages for AutoGen

This chapter includes several programs that either work closely
with AutoGen (extracting definitions or providing special formatting
functions), or else it is @code{mkmerge}.  I want to promote the
latter as an alternative to the builddir/srcdir schizophrenia.
I hate it. :(

AutoOpts ought to appear in this list also, but since it is
the primary reason why many people would even look into AutoGen
at all, I decided to leave it in the list of chapters.

@ignore
END   == AUTOINFO == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == AUTOFSM == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@node AutoFSM
@section Automated Finite State Machine
@cindex AutoFSM
@cindex finite state machine

The templates to generate a finite state machine in C or C++ is included
with AutoGen.  The documentation is not.  The documentation is in HTML
format for @uref{http://www.gnu.org/software/autogen/autofsm.html,viewing},
or you can @uref{http://download.sourceforge.net/autogen/,download FSM}.

@node AutoXDR
@section Combined RPC Marshalling
@cindex RPC
@cindex rpcgen
@cindex remote procedure call
@cindex AutoXDR
@cindex XDR

The templates and NFSv4 definitions are not included with AutoGen in any way.
The folks that designed NFSv4 noticed that much time and bandwidth was
wasted sending queries and responses when many of them could be bundled.
The protocol bundles the data, but there is no support for it in rpcgen.
That means you have to write your own code to do that.  Until now.
Download this and you will have a large, complex example of how to use
@code{AutoXDR} for generating the marshalling and unmarshalling of combined
RPC calls.  There is a brief example
@uref{http://www.gnu.org/software/autogen/xdr/index.html,on the web}, but
you should @uref{http://download.sourceforge.net/autogen/,download AutoXDR}.

@node AutoEvents
@section Automated Event Management
@cindex AutoEvents

Large software development projects invariably have a need to manage
the distribution and display of state information and state changes.
In other words, they need to manage their software events.  Generally,
each such project invents its own way of accomplishing this and then
struggles to get all of its components to play the same way.  It is a
difficult process and not always completely successful.  This project
helps with that.

AutoEvents completely separates the tasks of supplying the data
needed for a particular event from the methods used to manage the
distribution and display of that event.  Consequently, the programmer
writing the code no longer has to worry about that part of the
problem.  Likewise the persons responsible for designing the event
management and distribution no longer have to worry about getting
programmers to write conforming code.

This is a work in progress.  See my
@uref{http://www.gnu.org/software/autogen/autoevents.html,web page}
on the subject, if you are interested.
I have some useful things put together, but it is not ready
to call a product.

@ignore
END   == AUTOFSM == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@ignore
START == FUTURE == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore

@page
@node Future
@chapter Some ideas for the future.
@cindex futures

Here are some things that might happen in the distant future.

@itemize @bullet
@item
Write code for "AutoGetopts" (GNU getopt), or
possibly the new glibc argp parser.

@item
Fix up current tools that contain
miserably complex perl, shell, sed, awk and m4 scripts
to instead use this tool.
@end itemize
@page
@node Concept Index
@unnumbered Concept Index

@printindex cp
@page
@node Function Index
@unnumbered Function Index

@printindex fn
@page
@contents
@bye
@c  LocalWords:  AutoGen texinfo Korb tpl bruce Exp texi autogen setfilename AG
@c  LocalWords:  settitle setchapternewpage dne dircategory direntry ifinfo gpl
@c  LocalWords:  AutoOpts snprintfv titlepage vskip pt filll sp dir xref cindex
@c  LocalWords:  AutoGen's noindent rc ini enum IDX const az upcase ENDFOR ESAC
@c  LocalWords:  optargs egcs inclhack sh fixincl autoconf endif var templ dirs
@c  LocalWords:  def txt foo cd STR str ifdef alist downcase sprintf arg lexer
@c  LocalWords:  srcfile linenum subblock defParse srcdir sed POSIX printf expr
@c  LocalWords:  stdout expr func gfunc tr findex exparg desc desc sep macfunc
@c  LocalWords:  ing getdefs libopts src ksh forcomma csh env Sourced autoopts
@c  LocalWords:  mkmerge builddir ADDON AutoGetopts getopt glibc argp perl awk
@c  LocalWords:  printindex cp fn

@ignore
END   == FUTURE == DO NOT CHANGE THIS COMMENT or the surrounding 'ignore's
Extraction from autogen.texi
@end ignore
