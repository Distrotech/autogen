
DESCRIPTION:

Construct a character classification table and a collection of macros
to test a character's classification.

PURPOSE:

   This program will take a list of character classes and convert them
   into bit map tests.  If all you ever need are "isspace" or "isalpha"
   or the other tests included in <ctype.h>, then by all means use that.
   On the other hand, if you find yourself writing code like:
      if (isalnum(*p) || (*p == '_'))
   Then this might be handy.

EXAMPLE:

Here are the character classes I use in my test (and in autogen):

    lower-case      "a-z"
    upper-case      "A-Z"
    alphabetic      +lower-case   +upper-case
    oct-digit       "0-7"
    dec-digit       "89"          +oct-digit
    hex-digit       "a-fA-F"      +dec-digit
    alphanumeric    +alphabetic   +dec-digit
    var-first       "_"           +alphabetic
    variable-name   +var-first    +dec-digit
    option-name     "^-"          +variable-name
    value-name      ":"           +option-name
    horiz-white     "\t "
    compound-name   "[.]"         +value-name   +horiz-white
    whitespace      "\v\f\r\n\b"  +horiz-white
    unquotable      "!-~"         -"\"#(),;<=>[\\]`{}?*'"
    end-xml-token   "/>"          +whitespace
    graphic         "!-~"
    plus-n-space    "+"           +whitespace
    punctuation     "!-~"         -alphanumeric -"_"
    suffix          "-._"         +alphanumeric
    suffix-fmt      "%/"          +suffix     
    false-type      "nNfF0\x00"
    file-name       "/"           +suffix
    end-token       "\x00"        +whitespace
    end-list-entry  ","           +end-token
    set-separator   "|+"          +end-list-entry

The syntax is: class-name [ literal-string ] [{+|-}another-class]...
If a literal string is specified, then a new test bit is added.
If a character class is named, its bits are included or removed
from the character class set.

This table produces these (among other) macros and the "is_test_cmap_char" array:

#define  IS_LOWER_CASE_CHAR( _c)       is_ag_char_map_char((char)( _c), 0x000001)
#define SPN_LOWER_CASE_CHARS(_s)      spn_ag_char_map_chars((char *)_s, 0x000001)
#define BRK_LOWER_CASE_CHARS(_s)      brk_ag_char_map_chars((char *)_s, 0x000001)
#define  IS_UPPER_CASE_CHAR( _c)       is_ag_char_map_char((char)( _c), 0x000002)
#define SPN_UPPER_CASE_CHARS(_s)      spn_ag_char_map_chars((char *)_s, 0x000002)
#define BRK_UPPER_CASE_CHARS(_s)      brk_ag_char_map_chars((char *)_s, 0x000002)
[...]
#define  IS_SET_SEPARATOR_CHAR( _c)    is_ag_char_map_char((char)( _c), 0x700500)
#define SPN_SET_SEPARATOR_CHARS(_s)   spn_ag_char_map_chars((char *)_s, 0x700500)
#define BRK_SET_SEPARATOR_CHARS(_s)   brk_ag_char_map_chars((char *)_s, 0x700500)

and the code to scan over a valid variable name, for example,
looks like this:

   if (IS_VAR_FIRST_CHAR(*p)) {
      end = SPN_VARIABLE_NAME_CHARS(p);

"spn" and "brk" return pointers to the next (non-)matching character.
They do not return character counts.
