AutoGen Definitions strings;

string = { nm = bad_directive;
  str = "invalid directive: %s\n";
};

string = { nm = guard_fmt;
  str = "%s_GUARD";
};

string = { nm = define_fmt;
  str = "DEFINE_%s";
};

string = { nm = typedef_mask;
  str = "\ntypedef %s %s;\n\n";
};

string = { nm = declare_tbl;
  str = "extern %s const %s[%d];\n";
};

string = { nm = opterrmsg;
  str = "char-mapper error:  %s:  %s\n";
};

string = { nm = input_is_tty;
  str  = "input is from a TTY";
};

string = { nm = must_be_file;
  str  = "device must be file or pipe";
};

string = { nm = leader_fmt;
  str = <<- _EOString_
	/*
	 *   Character mapping generated %1$s
	 *
	%2$s */
	#ifndef %3$s
	#define %3$s 1

	#ifdef HAVE_CONFIG_H
	# if defined(HAVE_INTTYPES_H)
	#   include <inttypes.h>

	# elif defined(HAVE_STDINT_H)
	#   include <stdint.h>

	%4$s
	# endif /* HAVE_*INT*_H header */

	#else /* not HAVE_CONFIG_H -- */
	# include <inttypes.h>
	#endif /* HAVE_CONFIG_H */

	_EOString_;
};

string = { nm = type_8bits;
  str  = <<- _EOString_
	#   elif !defined(HAVE_UINT8_T)
	        typedef unsigned char   uint8_t;
	_EOString_;
};

string = { nm = type_16bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT16_T)
	    typedef unsigned short  uint16_t;
	_EOString_;
};

string = { nm = type_32bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT32_T)
	#   if SIZEOF_INT == 4
	      typedef unsigned int    uint32_t;
	#   elif SIZEOF_LONG == 4
	      typedef unsigned long   uint32_t;
	#   endif
	_EOString_;
};

string = { nm = type_64bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT64_T)
	#   if SIZEOF_LONG == 8
	      typedef unsigned long       uint64_t;
	#   elif SIZEOF_LONG_LONG == 8
	      typedef unsigned long long  uint64_t;
	#   endif
	_EOString_;
};

string = { nm = inline_functions;
  str = <<- _EOString_
	static inline int
	is_%1$s_char(char ch, %2$s mask)
	{
	    unsigned int ix = (unsigned char)ch;
	    return ((ix < %3$d) && ((%4$s[ix] & mask) != 0));
	}

	static inline char *
	spn_%1$s_chars(char * p, %2$s mask)
	{
	    while ((*p != '\0') && is_%1$s_char(*p, mask))  p++;
	    return p;
	}

	static inline char *
	brk_%1$s_chars(char * p, %2$s mask)
	{
	    while ((*p != '\0') && (! is_%1$s_char(*p, mask)))  p++;
	    return p;
	}

	_EOString_;
};

/*
 * "extra" text requested to be included in the output.
 */
string = { nm = emit_text_fmt;
  str = "\n/* emit text from map file: */\n\n%s\n";
};

string = { nm = start_static_table_fmt;
  str = "static %s const %s[%d] = {";
};

string = { nm = start_table_fmt;
  str = "#ifdef %s\n%s const %s[%d] = {";
};

/*
 * start and end of the copy of the input as a comment.
 */
string = { nm = copy_input_start;
  str = "\n#if 0 /* mapping specification source (from %s) */\n";
};

string = { nm = copy_input_end;
  str = "//\n#endif /* 0 -- mapping spec. source */\n\n";
};

string = { nm = macro_def_fmt;
  str = "#define  IS_%1$s_CHAR( _c)%2$s  is_%3$s_char((char)( _c), %4$s)\n"
        "#define SPN_%1$s_CHARS(_s)%2$s spn_%3$s_chars((char *)_s, %4$s)\n"
        "#define BRK_%1$s_CHARS(_s)%2$s brk_%3$s_chars((char *)_s, %4$s)\n";
};

string = { nm = mask_fmt_fmt;
  str = "0x%%0%dX";
};

string = { nm = char_map_gd;
  str = "CHAR_MAPPER_H_GUARD";
};

string = { nm = end_table;
  str = "\n};\n";
};

string = { nm = endif_fmt;
  str = "#endif /* %s */\n";
};

string = { nm = tname_fmt;
  str = "%s_table";
};

/*
 * Test main procedure formatting:
 */
string = { nm = testit_fmt;
  str = <<- _EOString_

	#ifdef TEST_%s
	int main (int argc, char ** argv) {
	    int ix = 0;
	    static char const header[] =
	_EOString_;
};

string = { nm = testit_class_names;
  str = "\n        \"%02X == %s\\n\"";
};

string = { nm = testit_class_hdrs;
  str = "\n        \"char is: ";
};

string = { nm = test_loop;
  str = <<- _EOString_
	\n";
	    fwrite(header, sizeof(header)-1, 1, stdout);

	    for (; ix<128; ix++) {
	        char ch = ((ix >= 0x20) && (ix < 0x7F)) ? ix : '?';
	        printf("0x%02X (%c) ", ix, ch);

	_EOString_; /* " */
};

string = { nm = each_test;
  str = "        putchar(' '); putchar(' ');\n"
        "        putchar(is_%s_char((char)ix, %s) ? 'X' : '.');\n";
};

string = { nm = endtest_fmt;
  str = <<- _EOString_
	    }
	    return 0;
	}
	#endif /* TEST_%s */

	_EOString_;
};

string = { nm = test_script_fmt;
  str = <<- _EOString_
	#if 0
	##  process this file with bash to test the classification result
	##  /usr/include/inttypes.h must exist
	base=%1$s-$$
	cfil=${base}.c
	set -e
	trap "rm -f ${base}*" EXIT
	cat > ${cfil} <<\_EOCode_
		#define TEST_%2$s         1
		#define DEFINE_%2$s_TABLE 1
		#define _GNU_SOURCE 1
		#include <stdio.h>
		#include "%3$s"
		_EOCode_

	${CC:-cc} -o ${base} ${base}.c
	./${base}
	rm -f ${base}*
	exit 0
	#endif

	_EOString_;
};

/*
 *  Usage text gets extracted from char-mapper.c into this ".def" file.
 */
string = { nm = usage_text;
#include cm-usage-text.def
};
