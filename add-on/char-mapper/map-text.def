AutoGen Definitions strings;

string = { nm = bad_directive;
  str = "invalid directive: %s\n";
};

string = { nm = guard_fmt;
  str = "%s_GUARD";
};

string = { nm = define_fmt;
  str = "DEFINE_%s";
};

string = { nm = typedef_mask;
  str = "\ntypedef %s %s;\n\n";
};

string = { nm = declare_tbl;
  str = "extern %s const %s[%d];\n";
};

string = { nm = opterrmsg;
  str = "char-mapper error:  %s:  %s\n";
};

string = { nm = input_is_tty;
  str  = "input is from a TTY";
};

string = { nm = table_sfx;
  str  = "_table";
};

string = { nm = must_be_file;
  str  = "device must be file or pipe";
};

string = { nm = leader_fmt;
  str = <<- _EOString_
	/*
	 *  %1$u bits for %2$u character classifications
	 *  generated by %7$s on %3$s
	 *
	%4$s */
	#ifndef %5$s
	#define %5$s 1

	#ifdef HAVE_CONFIG_H
	# if defined(HAVE_INTTYPES_H)
	#   include <inttypes.h>

	# elif defined(HAVE_STDINT_H)
	#   include <stdint.h>

	%6$s
	# endif /* HAVE_*INT*_H header */

	#else /* not HAVE_CONFIG_H -- */
	# include <inttypes.h>
	#endif /* HAVE_CONFIG_H */

	_EOString_;
};

string = { nm = type_8bits;
  str  = <<- _EOString_
	#   elif !defined(HAVE_UINT8_T)
	        typedef unsigned char   uint8_t;
	_EOString_;
};

string = { nm = type_16bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT16_T)
	    typedef unsigned short  uint16_t;
	_EOString_;
};

string = { nm = type_32bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT32_T)
	#   if SIZEOF_INT == 4
	      typedef unsigned int    uint32_t;
	#   elif SIZEOF_LONG == 4
	      typedef unsigned long   uint32_t;
	#   endif
	_EOString_;
};

string = { nm = type_64bits;
  str  = <<- _EOString_
	# elif !defined(HAVE_UINT64_T)
	#   if SIZEOF_LONG == 8
	      typedef unsigned long       uint64_t;
	#   elif SIZEOF_LONG_LONG == 8
	      typedef unsigned long long  uint64_t;
	#   endif
	_EOString_;
};

string = { nm = declare_opt_tbl;
  str = <<- _EOString_
	extern %1$s const %2$s_table[%3$d];
	extern unsigned char const * %2$s_spanners[%5$u];

	_EOString_;
};

string = { nm = inline_opt_functions;
  str = <<- _EOString_
	static inline int
	is_%1$s_char(char ch, %2$s mask)
	{
	    unsigned int ix = (unsigned char)ch;
	    return ((ix < %3$d) && ((%1$s_table[ix] & mask) != 0));
	}

	static inline char *
	spn_%1$s_chars(char * p, unsigned int mask_ix)
	{
	    unsigned char const * v = %1$s_spanners[mask_ix];
	    if (v == NULL)
	        v = calc_%1$s_spanners(mask_ix);
	    while (v[(unsigned)*p])  p++;
	    return p;
	}

	static inline char *
	brk_%1$s_chars(char * p, unsigned int mask_ix)
	{
	    unsigned char const * v = %1$s_spanners[mask_ix];
	    if (v == NULL)
	        v = calc_%1$s_spanners(mask_ix);
	    while ((*p != '\0') && (! v[(unsigned)*p]))  p++;
	    return p;
	}

	_EOString_;
};

string = { nm = inline_opt_backup;
  str = <<- _EOString_

	static inline char *
	spn_%1$s_back(char * s, char * e, unsigned int mask_ix)
	{
	    unsigned char const * v = %1$s_spanners[mask_ix];
	    if (v == NULL)
	        v = calc_%1$s_spanners(mask_ix);
	    if (s >= e) e = s + strlen(s);
	    while ((e > s) && v[(unsigned)e[-1]])  e--;
	    return e;
	}

	static inline char *
	brk_%1$s_back(char * s, char * e, unsigned int mask_ix)
	{
	    unsigned char const * v = %1$s_spanners[mask_ix];
	    if (v == NULL)
	        v = calc_%1$s_spanners(mask_ix);
	    if (s == e) e += strlen(e);
	    while ((e > s) && (! v[(unsigned)e[-1]]))  e--;
	    return e;
	}

	_EOString_;
};

string = { nm = inline_functions;
  str = <<- _EOString_
	static inline int
	is_%1$s_char(char ch, %2$s mask)
	{
	    unsigned int ix = (unsigned char)ch;
	    return ((ix < %3$d) && ((%4$s[ix] & mask) != 0));
	}

	static inline char *
	spn_%1$s_chars(char * p, %2$s mask)
	{
	    while ((*p != '\0') && is_%1$s_char(*p, mask))  p++;
	    return p;
	}

	static inline char *
	brk_%1$s_chars(char * p, %2$s mask)
	{
	    while ((*p != '\0') && (! is_%1$s_char(*p, mask)))  p++;
	    return p;
	}

	_EOString_;
};

string = { nm = inline_backup;
  str = <<- _EOString_

	static inline char *
	spn_%1$s_back(char * s, char * e, %2$s mask)
	{
	    if (s >= e) e = s + strlen(s);
	    while ((e > s) && is_%1$s_char(e[-1], mask))  e--;
	    return e;
	}

	static inline char *
	brk_%1$s_back(char * s, char * e, %2$s mask)
	{
	    if (s == e) e += strlen(e);
	    while ((e > s) && (! is_%1$s_char(e[-1], mask)))  e--;
	    return e;
	}

	_EOString_;
};

/*
 * "extra" text requested to be included in the output.
 */
string = { nm = emit_text_fmt;
  str = "\n/* emit text from map file: */\n\n%s\n";
};

string = { nm = start_static_table_fmt;
  str = "static %s const %s[%d] = {\n ";
};

string = { nm = start_table_fmt;
  str = "#ifdef %s\n%s const %s[%d] = {\n ";
};

string = { nm = optimize_fmt;
  str = <<- _EOString_

	#include <stdlib.h>
	#include <string.h>

	%1$sunsigned char const * %2$s_spanners[%3$u];
	/**
	 *  Character category masks.  Some categories may have multiple bits,
	 *  if their definition incorporates other character categories.
	 *  This mask array is only used by calc_%2$s_spanners().
	 */
	static %2$s_mask_t const %2$s_masks[%3$u] = {

	_EOString_;
};

string = { nm = pthread_locking;
  str = <<- _EOString_
	};

	#include <pthread.h>
	static pthread_mutex_t %1$s_mutex = PTHREAD_MUTEX_INITIALIZER;

	#define lock_%1$s_spanners() \
	    pthread_mutex_lock(&%1$s_mutex)

	#define unlock_%1$s_spanners() \
	    pthread_mutex_unlock(&%1$s_mutex)

	_EOString_;
};

string = { nm = no_locking;
  str = <<- _EOString_
	};

	#define lock_%1$s_spanners()
	#define unlock_%1$s_spanners()

	_EOString_;
};

string = { nm = fill_opt_fmt;
  str = <<- _EOString_

	%2$sunsigned char const *
	calc_%1$s_spanners(unsigned int mask_ix)
	{
	    lock_%1$s_spanners();
	    if (%1$s_spanners[mask_ix] == NULL) {
	        int ix = 1;
	        %1$s_mask_t mask = %1$s_masks[mask_ix];
	        unsigned char * res = malloc(256 /* 1 << NBBY */);
	        memset(res, 0, 256);
	        for (; ix < 128; ix++)
	            if (%1$s_table[ix] & mask)
	                res[ix] = 1;
	        %1$s_spanners[mask_ix] = res;
	    }
	    unlock_%1$s_spanners();
	    return %1$s_spanners[mask_ix];
	}
	#define %1$s_masks POISONED_%1$s_masks


	_EOString_;
};

/*
 * start and end of the copy of the input as a comment.
 */
string = { nm = copy_input_start;
  str = "\n#if 0 /* mapping specification source (from %s) */\n";
};

string = { nm = copy_input_end;
  str = "//\n#endif /* 0 -- mapping spec. source */\n\n";
};

string = { nm = macro_def_fmt;
  str = "#define  IS_%1$s_CHAR( _c)%2$s  is_%3$s_char((char)( _c), %4$s)\n"
        "#define SPN_%1$s_CHARS(_s)%2$s spn_%3$s_chars((char *)_s, %5$s)\n"
        "#define BRK_%1$s_CHARS(_s)%2$s brk_%3$s_chars((char *)_s, %5$s)\n";
};

string = { nm = backup_def_fmt;
  str = "#define SPN_%1$s_BACK(s,e)%2$s "
                "spn_%3$s_back((char *)s, (char *)e, %4$s)\n"
        "#define BRK_%1$s_BACK(s,e)%2$s "
                "brk_%3$s_back((char *)s, (char *)e, %4$s)\n";
};

string = { nm = mask_fmt_fmt;
  str = "0x%%0%dX";
};

string = { nm = char_map_gd;
  str = "CHAR_MAPPER_H_GUARD";
};

string = { nm = end_table;
  str = "\n};\n";
};

string = { nm = endif_fmt;
  str = "#endif /* %s */\n";
};

string = { nm = tname_fmt;
  str = "%s_table";
};

/*
 * Test main procedure formatting:
 */
string = { nm = testit_fmt;
  str = <<- _EOString_

	#ifdef TEST_%s
	int main (int argc, char ** argv) {
	    int ix = 0;
	    static char const header[] =
	_EOString_;
};

string = { nm = testit_class_names;
  str = "\n        \"%02X == %s\\n\"";
};

string = { nm = testit_class_hdrs;
  str = "\n        \"char is: ";
};

string = { nm = test_loop;
  str = <<- _EOString_
	\n";
	    fwrite(header, sizeof(header)-1, 1, stdout);

	    for (; ix<128; ix++) {
	        char ch = ((ix >= 0x20) && (ix < 0x7F)) ? ix : '?';
	        printf("0x%02X (%c) ", ix, ch);

	_EOString_; /* " */
};

string = { nm = each_test;
  str = "        putchar(' '); putchar(' ');\n"
        "        putchar(is_%s_char((char)ix, %s) ? 'X' : '.');\n";
};

string = { nm = endtest_fmt;
  str = <<- _EOString_
	    }
	    return 0;
	}
	#endif /* TEST_%s */

	_EOString_;
};

string = { nm = test_script_fmt;
  str = <<- _EOString_
	#if 0
	##  process this file with bash to test the classification result
	##  /usr/include/inttypes.h must exist
	base=%1$s-$$
	cfil=${base}.c
	set -e
	trap "rm -f ${base}*" EXIT
	cat > ${cfil} <<\_EOCode_
		#define TEST_%2$s         1
		#define DEFINE_%2$s_TABLE 1
		#define _GNU_SOURCE 1
		#include <stdio.h>
		#include "%3$s"
		_EOCode_

	${CC:-cc} -o ${base} ${base}.c
	./${base}
	rm -f ${base}*
	exit 0
	#endif

	_EOString_;
};

/*
 *  Usage text gets extracted from char-mapper.c into this ".def" file.
 */
string = { nm = usage_text;
#include cm-usage-text.def
};
