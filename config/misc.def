
autogen definitions conftest.tpl;

/*
 */ author =           "Bruce Korb <bkorb@gnu.org>";
/*  Created:           Tue Nov 24 01:07:30 1998
 *  Last Modified:     $Date: 2002/03/23 05:06:56 $
 *             by: bkorb
 *  -------------------------------------------------------------------
 *  $Id: misc.def,v 3.9 2002/03/23 05:06:56 bkorb Exp $
 *  -------------------------------------------------------------------
 */
group = ag;
version = "$Revision: 3.9 $";
output-file = ag_macros.m4;

test = {
    name   = shell;
    type   = disable;
    check  = 'using shell scripts';
    action = { act-type = define; };

    action = { act-type = script;
      act-text = <<-  _EOF_
		AC_SUBST(OPTS_TESTDIR)
		    AC_SUBST(TOP_DIRLIST)
		    AC_SUBST(AGEN5_TESTS)
		    TOP_DIRLIST='$(SHELL_DIRS)'
		    OPTS_TESTDIR=test
		    AGEN5_TESTS='$(SHELL_TESTS) $(NOSHELL_TESTS)'
		_EOF_; };

    action = { no; act-type = script;
      act-text = <<-  _EOF_
		TOP_DIRLIST='$(NOSHELL_DIRS)'
		    OPTS_TESTDIR=
		    AGEN5_TESTS='$(NOSHELL_TESTS)'
		_EOF_; };

    doc = <<-  _EOF_
	AutoGen is now capable of acting as a CGI service.  In that capacity,
	it is extremely dangerous to allow text to be interpreted by a shell.
	To ensure that that cannot happen accidentally, it is best to
	completely disable subshell services by specifying, --disable-shell.
	In the default, enabled state, the "yes-subst[itution]" will enable
	the getdefs, columns and doc subdirectory builds.
	_EOF_;
};

test = {
    name   = debug;
    type   = enable;
    check  = 'wanting autogen debugging';
    action = { act-type = define; };
    /*
     *  What to do for non-default
     */
    action = { act-type = script;
      act-text = <<- _EOF_
		CPPFLAGS="-DDEBUG $CPPFLAGS"
	    CFLAGS="-g `echo $CFLAGS|sed 's%-g *%%g;s%-O[0-9]* *%%g'`"
		_EOF_; };

    doc = <<-  _EOF_
	This option will enable two debugging options for AutoGen.
	viz., --show-defs (dump out the definition tree)
	and --show-shell (print out all shell commands via `set -x')
	_EOF_;
};

test   = {
  name     = "regex_header";
  type     = "with";
  check    = "a reg expr header is specified";
  action   = { yes; act-type=subst;
               act-text = "<${ag_cv_with_regex_header}>"; };
  action   = { no;  act-type=subst;
               act-text = "<regex.h>"; };

  doc = "When using alternative libraries, sometimes you must use\n"
        "alternative header file names, too.";
};

test   = {
  name     = "regex_header_path";
  type     = "with";
  check    = "a path to the reg-ex header is specified";
  action   = { yes; act-type=subst;
               act-text = "-I${ag_cv_with_regex_header_path}"; };
  action   = { no;  act-type=subst;  act-text = ""; };
  action   = { yes; asis;
    act-type = script;
    act-text = 'CPPFLAGS="${CPPFLAGS} -I${ag_cv_with_regex_header_path}"';
  };

  doc     = "If the reg-ex header is not in the normal path, the\n"
            "installer will have to specify it with this.";
};

test = {
    name   = posix_regcomp;
    type   = run;
    omit-invocation; /* see --with-regex-lib below */
    check  = "regcomp()/regexec() is POSIX compliant";
    action = { no; act-type = script;
    act-text = <<-  _END_OF_ACTION
    cat >&2 <<'_EOF_'
		I cannot detect POSIX compliant regcomp/regexec routines.
		These are required for AutoGen to work correctly.  If you have
		such a library present on your system, you must specify it by
		setting the LIBS environment variable, e.g., "LIBS='-lregex'".
		If you do not have such a library on your system, then you should
		download and install, for example, the one from:
		    ftp://ftp.gnu.org/gnu/rx/
		_EOF_
		exit 1
		_END_OF_ACTION;
    };
    code   = <<-  _EOF_
		#include <sys/types.h>
		#include ${AG_REGEX_HEADER}
		int main() {
		  int flags = REG_EXTENDED|REG_ICASE|REG_NEWLINE;
		  regex_t  re;
		  if (regcomp( &re, "^.*$", flags ) != 0)
		    return 1;
		  return regcomp( &re, "|no.*", flags ); }
		_EOF_;

    doc =
    "Check that the POSIX compliant regular expression compiler\n"
    "is available in the POSIX specified manner, and it works.\n"
    "If it fails, there is a backup.  Specify:  --with-regex-lib=-lwhatever";
};

test   = {
  name     = "regex_lib";
  type     = "with";
  check    = "a special reg-ex library is specified";
  action   = { yes; act-type=subst;  act-text = "${ag_cv_with_regex_lib}"; };
  action   = { no;  act-type=subst;  act-text = ""; };

  action   = { yes; asis;
    act-type = script;
    act-text = 'LDFLAGS="${LDFLAGS} ${ag_cv_with_regex_lib}"';
  };

  action   = { no; asis;
    act-type = script;
    act-text = 'AG_RUN_POSIX_REGCOMP';
  };

  doc = <<- _END_OF_DOC_
		This option must specify any ``-lmumble'' option required
		for linking.  If a ``-L'' option is needed as well, then
		it should include that as well.  The ``-l'' and ``-L'' must
		be part of the string value.

		If this option is not supplied, then the AG_POSIX_REGCOMP
		will be run to verify that POSIX regular expressions are
		available.  AutoGen will not work without them.
		_END_OF_DOC_;
};

test = {
    name   = allocated_ctime;
    type   = run;
    check  = "ctime() allocates memory for its result";
    action = { act-type = define; };
    code   = <<-  _EOF_
		#include <time.h>
		int main (int argc, char** argv) {
		   time_t  timeVal = time( (time_t*)NULL );
		   char*   pzTime  = ctime( &timeVal );
		   free( (void*)pzTime );
		   return 0; }
		_EOF_;

    doc =
    "Check whether we need to free the memory returned by ctime.";
};

test = {
    name   = pathfind;
    type   = run;
    check  = "pathfind(3) works";
    action = { act-type = define; };
    action = { no; act-type = script;
               act-text = 'COMPATOBJ="$COMPATOBJ pathfind.lo"'; };

    code   = <<-  _EOF_
		#include <string.h>
		#include <stdlib.h>
		int main (int argc, char** argv) {
		   char* pz = pathfind( getenv( "PATH" ), "sh", "x" );
		   return (pz == 0) ? 1 : 0;
		}
		_EOF_;

    doc =
    "Not all systems have pathfind(3).  See if we need to substitute.\n"
    "To make this work, you have to do horrible things.  See the doc\n"
    "for AG_CHECK_STRCSPN.";
};

test = {
    name   = posix_sysinfo;
    type   = run;
    check  = "sysinfo(2) is POSIX";
    action = { act-type = define; };
    code   = <<- _EOF_
		#include <sys/systeminfo.h>
		int main() { char z[ 256 ];
		long sz = sysinfo( SI_SYSNAME, z, sizeof( z ));
		return (sz > 0) ? 0 : 1; }
		_EOF_;
    doc =
    "Check that the POSIX compliant sysinfo(2) call works properly.\n"
    "Linux has its own weirdo alternative.";
};

test = {
    name   = strcspn;
    type   = run;
    check  = "strcspn matches prototype and works";
    action = { act-type = define; };
    action = { no; act-type = script;
			act-text = 'COMPATOBJ="$COMPATOBJ strcspn.lo"'; };

    code   = <<-  _EOF_
		#include <string.h>
		int main (int argc, char** argv) {
		   char zRej[] = "reject";
		   char zAcc[] = "a-ok-eject";
		   return strcspn( zAcc, zRej ) - 5;
		}
		_EOF_;

    doc =
    "Not all systems have strcspn(3).  See if we need to substitute.\n"
    "To make this work, you have to do horrible things.  In one of your\n"
    "Makefile.am files, you must make an explicit rule to make this object.\n"
    "It should look like this:\n"
    "  strcspn.lo : $(top_srcdir)/compat/strcspn.c\n"
    "      $(LTCOMPILE) -o $@ -c $(top_srcdir)/compat/strcspn.c\n"
    "and you must include ``@COMPATOBJ@'' in a LIBADD somewhere and,\n"
    "finally, you must add another artificial dependency, something like:\n"
    "  makeshell.lo : genshell.c @COMPATOBJ@\n"
    "It is all pretty horrific, but I have found nothing else that works.";
};

test = {
    name  = strftime;
    type  = run;
    check = "strftime() works";
    action = { act-type = define; };
    code  = <<-  _EOF_
		#include <time.h>
		#include <string.h>
		char t_buf[ 64 ];
		int main() {
		  static const char z[] = "Thursday Aug 28 240";
		  struct tm tm;
		  tm.tm_sec   = 36;  /* seconds after the minute [0, 61]  */
		  tm.tm_min   = 44;  /* minutes after the hour [0, 59] */
		  tm.tm_hour  = 12;  /* hour since midnight [0, 23] */
		  tm.tm_mday  = 28;  /* day of the month [1, 31] */
		  tm.tm_mon   =  7;  /* months since January [0, 11] */
		  tm.tm_year  = 86;  /* years since 1900 */
		  tm.tm_wday  =  4;  /* days since Sunday [0, 6] */
		  tm.tm_yday  = 239; /* days since January 1 [0, 365] */
		  tm.tm_isdst =  1;  /* flag for daylight savings time */
		  strftime( t_buf, sizeof( t_buf ), "%A %b %d %j", &tm );
		  return (strcmp( t_buf, z ) != 0); }
		_EOF_;

    doc =
    "Check for existence and functioning of strftime routine.";
};

test = {
    name   = sys_siglist;
    type   = run;
    check  = "there is a global text array sys_siglist";
    action = { act-type = define; };

    code   = <<-  _EOF_
		#include <signal.h>
		int main() {
		  const char* pz = sys_siglist[1];
		  return (pz != 0) ? 0 : 1; }
		_EOF_;

    doc =
    "Check that the POSIX compliant regular expression compiler\n"
    "is available in the POSIX specified manner, and it works.";
};

test = {
    name   = uname_syscall;
    type   = run;
    check  = "uname(2) is POSIX";
    action = { act-type = define; };
    code   = <<- _EOF_
		#include <sys/utsname.h>
		int main() { struct utsname unm;
		return uname( &unm ); }
		_EOF_;
    doc =
    "Check that the POSIX compliant uname(2) call works properly.";
};

test = {
    name   = fopen_binary;
    type   = run;
    check  = 'fopen accepts "b" mode';
    action = { act-type = script; asis;
      act-text = "AC_DEFINE([FOPEN_BINARY_FLAG],\"b\",\n\t"
                 "[fopen(3) accepts a 'b' in the mode flag])"; };
    action = { act-type = script; asis; no;
      act-text = "AC_DEFINE([FOPEN_BINARY_FLAG],\"\",\n\t"
                 "[fopen(3) accepts a 'b' in the mode flag])"; };
    code   = <<- _EOF_
		#include <stdio.h>
		int main (int argc, char** argv) {
		FILE* fp = fopen("conftest.$ac_ext", "rb");
		return (fp == NULL) ? 1 : fclose(fp); }
		_EOF_;
    doc = <<- _END_OF_DOC_
		Test whether fopen accepts a "b" in the mode string for binary file
		opening.  This makes no difference on most unices, but some OSes
		convert every newline written to a file to two bytes (CR LF), and
		every CR LF read from a file is silently converted to a newline.
		_END_OF_DOC_;
};

test = {
    name   = fopen_text;
    type   = run;
    check  = 'fopen accepts "t" mode';
    action = { act-type = script; asis;
      act-text = "AC_DEFINE([FOPEN_TEXT_FLAG],\"t\",\n\t"
                 "[fopen(3) accepts a 't' in the mode flag])"; };
    action = { act-type = script; asis; no;
      act-text = "AC_DEFINE([FOPEN_TEXT_FLAG],\"\",\n\t"
                 "[fopen(3) accepts a 't' in the mode flag])"; };
    code   = <<- _EOF_
		#include <stdio.h>
		int main (int argc, char** argv) {
		FILE* fp = fopen("conftest.$ac_ext", "rt");
		return (fp == NULL) ? 1 : fclose(fp); }
		_EOF_;
    doc = <<- _END_OF_DOC_
		Test whether fopen accepts a "t" in the mode string for text file
		opening.  This makes no difference on most unices, but some OSes
		convert every newline written to a file to two bytes (CR LF), and
		every CR LF read from a file is silently converted to a newline.
		_END_OF_DOC_;
};

do-always = <<- _END_ALWAYS_

	# Give preference to byacc and yacc over bison.
	# bison likes alloca.  I hate alloca.  It is not portable.
	# This is a rehack of AC_PROG_YACC
	AC_CHECK_PROGS(YACC, byacc yacc 'bison -y', "$missing_dir/missing yacc")

	_END_ALWAYS_;

/* misc.def ends here */
