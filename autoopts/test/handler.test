#! /bin/sh
#  -*- Mode: Shell-script -*-
# ----------------------------------------------------------------------
# handler.test ---   test option handling
#                    make sure that when it is not specified
#                    then option processing consumes all args.
#
# Time-stamp:        "2008-07-27 11:48:04 bkorb"
# Author:            Bruce Korb <bkorb@gnu.org>
# Last Modified:     $Date: 2008/07/27 20:06:05 $
#            by: bkorb
##
##  This file is part of AutoOpts, a companion to AutoGen.
##  AutoOpts is free software.
##  AutoOpts is copyright (c) 1992-2008 by Bruce Korb - all rights reserved
##  AutoOpts is copyright (c) 1992-2008 by Bruce Korb - all rights reserved
##
##  AutoOpts is available under any one of two licenses.  The license
##  in use must be one of these two and the choice is under the control
##  of the user of the license.
##
##   The GNU Lesser General Public License, version 3 or later
##      See the files "COPYING.lgplv3" and "COPYING.gplv3"
##
##   The Modified Berkeley Software Distribution License
##      See the file "COPYING.mbsd"
##
##  These files have the following md5sums:
##
##  239588c55c22c60ffe159946a760a33e pkg/libopts/COPYING.gplv3
##  fa82ca978890795162346e661b47161a pkg/libopts/COPYING.lgplv3
##  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd
#
# $Id: handler.test,v 4.20 2008/07/27 20:06:05 bkorb Exp $
# ----------------------------------------------------------------------

. ./defs

# # # # # # # # # # DEFINITIONS FILE # # # # # # # # #

echo "creating ${testname}.def in `pwd`"
cat > ${testname}.def <<_EOF_
AutoGen Definitions options;
prog-name = ${testname};
prog-title = "Testing ${testname}";

flag = {
    name = first;
    descrip = "first description";
    extract_code;
};

flag = {
    name = second;
    descrip = "second description";
    arg-type = keyword;
    keyword = alpha, beta, gamma, omega;
};

flag = {
    name = third;
    descrip = "third description";
    flag_code = "    SomeCodeOrOther();";
};

flag = {
    name = fourth;
    descrip = "fourth description";
    arg-type = keyword;
    keyword = alpha, beta, gamma, omega;
    arg-default = gamma;
    arg-optional;
};

flag = {
    name = fifth;
    descrip = "fifth description";
    flag_proc = first;
};

flag = {
    name = sixth;
    descrip = "sixth description";
    arg-type = set-member;
    keyword = alpha, beta, gamma, omega;
    arg-default = gamma, beta;
};
_EOF_

echo ${AG_L} ${testname}.def
${AG_L} ${testname}.def || \
  failure AutoGen could not process

sed '/START =/a\
SampleCode();\
XXX-REMOVE-XXX' ${testname}.c > ${testname}.tmp
chmod 644 ${testname}.c
sed -e '/^XXX-REMOVE-XXX$/d;s/XXX-REMOVE-XXX//' \
    ${testname}.tmp > ${testname}.c

${AG_L} ${testname}.def || \
  failure AutoGen could not process

# We are testing to ensure the procedures are created correctly.
# The template line numbers and time stamps and all that cruft
# vary too much, so sed them away.
#
sed -e '1,/Create the static procedure(s) declared above/d' \
    -e '/extracted from.*near line/d' -e '/^#line/d' \
    ${testname}.c > ${testname}.test

# # # # # # # # # # SAMPLE OUTPUT FILE # # # # # # # # #

echo creating ${testname}.sample
cat > ${testname}.sample <<\_EOF_
 */
static void
doUsageOpt(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    USAGE( EXIT_SUCCESS );
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the first option.
 */
static void
doOptFirst(tOptions* pOptions, tOptDesc* pOptDesc)
{
/*  START =-= First Opt Code =-= DO NOT CHANGE THIS COMMENT */
SampleCode();
/*  END   =-= First Opt Code =-= DO NOT CHANGE THIS COMMENT */
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the second option.
 */
static void
doOptSecond(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static char const zDef[2] = { 0x7F, 0 };

    static char const * const azNames[5] = { zDef,
        "alpha",  "beta",   "gamma",  "omega"
    };

    if (pOptions <= OPTPROC_EMIT_LIMIT) {
        (void) optionEnumerationVal(pOptions, pOptDesc, azNames, 5);
        return; /* protect AutoOpts client code from internal callbacks */
    }

    pOptDesc->optArg.argEnum =
        optionEnumerationVal( pOptions, pOptDesc, azNames, 5 );

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the third option.
 */
static void
doOptThird(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from handler.def, line 21 */
    SomeCodeOrOther();
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the fourth option.
 */
static void
doOptFourth(tOptions* pOptions, tOptDesc* pOptDesc)
{

    static char const * const azNames[4] = {
        "alpha",  "beta",   "gamma",  "omega"
    };

    if (pOptions <= OPTPROC_EMIT_LIMIT) {
        (void) optionEnumerationVal(pOptions, pOptDesc, azNames, 4);
        return; /* protect AutoOpts client code from internal callbacks */
    }

    if (pOptDesc->optArg.argString == NULL)
        pOptDesc->optArg.argEnum = FOURTH_GAMMA;
    else
        pOptDesc->optArg.argEnum =
            optionEnumerationVal(pOptions, pOptDesc, azNames, 4);

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the sixth option.
 */
static void
doOptSixth(tOptions* pOptions, tOptDesc* pOptDesc)
{

    static char const * const azNames[4] = {
        "alpha",  "beta",   "gamma",  "omega"
    };
    optionSetMembers(pOptions, pOptDesc, azNames, 4);
}

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext( char const* pz );
static void  coerce_it(void** s);

static char*
AO_gettext( char const* pz )
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup( pzRes );
    if (pzRes == NULL) {
        fputs( _("No memory for duping translated strings\n"), stderr );
        exit( EXIT_FAILURE );
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s); }
#define COERSION(_f) \
  coerce_it((void*)&(handlerOptions._f))

/*
 *  This invokes the translation code (e.g. gettext(3)).
 */
static void
translate_option_strings( void )
{
    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct != 0) {

        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        tOptDesc* pOD = handlerOptions.pOptDesc;
        char**    ppz = (char**)(void*)&(option_usage_text);
        int       ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);

        COERSION(pzCopyright);
        COERSION(pzCopyNotice);
        COERSION(pzFullVersion);
        COERSION(pzUsageTitle);
        COERSION(pzExplain);
        COERSION(pzDetail);
        option_usage_text.field_ct = 0;

        for (ix = handlerOptions.optCt; ix > 0; ix--, pOD++)
            coerce_it((void*)&(pOD->pzText));
    }

    if ((handlerOptions.fOptSet & OPTPROC_NXLAT_OPT_CFG) == 0) {
        tOptDesc* pOD = handlerOptions.pOptDesc;
        int       ix;

        for (ix = handlerOptions.optCt; ix > 0; ix--, pOD++) {
            coerce_it((void*)&(pOD->pz_Name));
            coerce_it((void*)&(pOD->pz_DisableName));
            coerce_it((void*)&(pOD->pz_DisablePfx));
        }
        /* prevent re-translation */
        handlerOptions.fOptSet |= OPTPROC_NXLAT_OPT_CFG | OPTPROC_NXLAT_OPT;
    }
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* handler.c ends here */
_EOF_

cmp -s ${testname}.test ${testname}.sample || { set +x ; \
  failure "`diff -c ${testname}.test ${testname}.sample`" ; }

cleanup

## Local Variables:
## mode: shell-script
## indent-tabs-mode: nil
## sh-indentation: 2
## End:

# end of handler.test
