autogen definitions options;

/*
 *   $Id: opts.def,v 1.11 1999/02/26 15:57:13 bkorb Exp $
 */

/*
 *  Autogen copyright 1992-1998 Bruce Korb
 *
 *  Autogen is free software.
 *  You may redistribute it and/or modify it under the terms of the
 *  GNU General Public License, as published by the Free Software
 *  Foundation; either version 2, or (at your option) any later version.
 *
 *  Autogen is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Autogen.  See the file "COPYING".  If not,
 *  write to:  The Free Software Foundation, Inc.,
 *             59 Temple Place - Suite 330,
 *             Boston,  MA  02111-1307, USA.
 */

copyright = "1998";
copyright_gpl;

owner          = "Bruce Korb";
prog_name      = "columns";
prog_title     = "Columnize Input Text";
long_opts;

explain =
'This program will read a list of text items from standard in
or a specified input and produce a columnized listing of all
the non-blank lines.';

version = 1;

flag = {
    name      = width;
    value     = W;
    flag_arg  = "=79";
    descrip   = "Maximum Line Width";
    doc       =
    "This option specifies the full width of the output line,\n"
    "including any start-of-line indentation.  The output will fill\n"
    "each line as completely as possible, unless the column width has\n"
    "been explicitly specified.  If the maximum width is less than\n"
    "the length of the widest input, you will get a single column\n"
    "of output.";
};

flag = {
    name      = columns;
    value     = c;
    flag_arg  = "=0";
    descrip   = "Desired number of columns";
    doc =
    "Use this option to specify exactly how many columns to produce.\n"
    "If that many columns will not fit within @var{line_width}, then\n"
    "the number will automatically be reduced to that which will fit.";
};

flag = {
    name      = col_width;
    value     = w;
    flag_arg  = "=0";
    descrip   = "Set width of each column";
    doc =
    "Use this option to specify exactly how many characters are to be\n"
    "allocated for each column.  If it is narrower than the widest entry,\n"
    "it will be over-ridden with the required width.";
};

flag = {
    name      = spread;
    flag_arg  = "=0";
    descrip   = "maximum spread added to column width";
    doc =
    "Use this option to specify exactly how many characters may be\n"
    "added to each column.  It allows you to prevent columns from\n"
    "becoming too far apart.";
};

flag = {
    name      = indent;
    value     = I;
    flag_arg  = ":";
    descrip   = "Line prefix or indentation";
    doc =
    "If a number, then this many spaces will be inserted at the start of\n"
    "every line.  Otherwise, it is a line prefix that will be inserted\n"
    "at the start of every line.";
};

flag = {
    name      = tab_width;
    flag_arg  = "=8";
    descrip   = "tab width";
    doc =
    "If an indentation string contains tabs, then this value is used to\n"
    "compute the ending column of the prefix string.";
};

flag = {
    name      = sort;
    value     = s;
    flag_arg;
    descrip   = "Sort input text";
    doc =
    "Causes the input text to be sorted.  If an argument is supplied,\n"
    "it is presumed to be a pattern and the sort is based upon the\n"
    "matched text.  If the pattern starts with or consists of\n"
    "an asterisk (@code{*}), then the sort is case insensitive.";
};

flag = {
    name      = format;
    value     = f;
    flag_arg  = ':';
    descrip   = "Formatting string for each input";
    doc =
    "If you need to reformat each input text, the argument to this\n"
    "option is interpreted as an @code{sprintf(3)} format that is used\n"
    "to produce each output entry.";
};

flag = {
    name      = separation;
    value     = S;
    flag_arg  = ':';
    descrip   = "Separation string - follows all but last";
    doc =
    "Use this option if, for example, you wish a comma to appear after\n"
    "each entry except the last.";
};

flag = {
    name      = line_separation;
    flag_arg  = ':';
    descrip   = "string at end of all lines but last";
    doc =
    "Use this option if, for example, you wish a backslash to appear at\n"
    "the end of every line, except the last.";
};

flag = {
    name      = by_columns;
    descrip   = "Print entries in column order";
    doc =
"Normally, the entries are printed out in order by rows and then columns.
This option will cause the entries to be ordered within columns.  The final
column, instead of the final row, may be shorter than the others.";
};

#ifdef LATER
flag = {
    name      = page_len;
    flag_arg  = "=0";
    descrip   = "Page Length";
    doc =
    "This many lines will be printed before a form feed is emitted.\n"
    "The 'by_columns' ordering will wrap columns within a page.";
};
#endif

flag = {
    name      = input;
    value     = i;
    flag_arg  = ":";
    descrip   = "Input file (if not stdin)";
    flag_code =
'    FILE* fp = freopen( pOptDesc->pzLastArg, "r" FOPEN_BINARY_FLAG, stdin );
    if (fp == (FILE*)NULL) {
        fprintf( stderr, "Error %d (%s) opening %s\n",
                 errno, strerror( errno ), pOptDesc->pzLastArg );
        USAGE( EXIT_FAILURE );
    }';
    doc =
    "This program normally runs as a @code{filter}, reading from standard\n"
    "input, columnizing and writing to standard out.  This option redirects\n"
    "input to a file.";
};

include = "#include <stdio.h>\n"
          "#include <errno.h>\n"
          "#ifdef HAVE_CONFIG_H\n"
          '#  include "config.h"'  "\n"
          "#endif\n"
          "#ifdef USE_FOPEN_BINARY\n"
          '#  define FOPEN_BINARY_FLAG "b"'  "\n"
          "#else\n"
          "#  define FOPEN_BINARY_FLAG\n"
          "#endif";
