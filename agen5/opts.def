/* -*- Mode: C -*- */

autogen definitions options;

/*
 *   $Id: opts.def,v 1.26 2000/10/17 03:56:54 bkorb Exp $
 */

/*
 *  AutoGen copyright 1992-2000 Bruce Korb
 *
 *  AutoGen is free software.
 *  You may redistribute it and/or modify it under the terms of the
 *  GNU General Public License, as published by the Free Software
 *  Foundation; either version 2, or (at your option) any later version.
 *
 *  AutoGen is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with AutoGen.  See the file "COPYING".  If not,
 *  write to:  The Free Software Foundation, Inc.,
 *             59 Temple Place - Suite 330,
 *             Boston,  MA  02111-1307, USA.
 */

copyright = {
    date  = "1992-2000";
    owner = "Bruce Korb";
    type  = gpl;
};

eaddr          = "bkorb@gnu.org";
prog_name      = "autogen";
prog_title     = "The Automated Program Generator";
argument       = "[ <def-file> ]";
homerc         = $HOME, ".";
environrc;
long_opts;
include        = '#include "autogen.h"';

version = `
    if test -z "$top_srcdir" || test ! -d "$top_srcdir"; then
        top_srcdir=..
    fi
    if test ! -f $top_srcdir/VERSION ; then
        echo "#error $top_srcdir/VERSION file missing"
    else
        . $top_srcdir/VERSION > /dev/null
        echo $AG_VERSION
    fi`;

explain =
"AutoGen creates text files from templates using external definitions.";

detail =

"The definitions file (`<def-file>') can be specified with the
`definitions' option or as the command argument, but not both.
Omitting it or specifying `-' will result in reading definitions from
standard input.

The output file names are based on the template, but generally use the
base name of the definition file.  If standard in is read for the
definitions, then `stdin' will be used for that base name.  The
suffixes to the base name are gotten from the template.  However, the
template file may specify the entire output file.

`loop-limit' is used in debugging to stop runaway expansions.";

flag = {
    name      = templ_dirs;
    value     = L;
    arg_type  = string;
    descrip   = "Template search directory list";
    max       = NOLIMIT;
    arg_name  = dir;
    stack_arg;
    settable;
    doc =
    "Add a directory to the list of directories to search when opening\n"
    "a template, either as the primary template or an included one.";
};

flag = {
    name      = override_tpl;
    value     = T;
    arg_type  = string;
    arg_name  = tpl-file;
    no_preset;
    descrip   = "Override template file";
    doc =
    "Definition files specify the standard template that is to be expanded.\n"
    "This option will override that name and expand a different template.";

    flag_code =
"    extern char* pzTemplFileName;
    pzTemplFileName = pOptDesc->pzLastArg;";
};

flag = {
    name      = lib_template;
    value     = l;
    arg_type  = string;
    max       = NOLIMIT;
    arg_name  = tpl-file;
    descrip   = "Library template file";
    doc =
    "DEFINE macros are saved from this template file for use in processing\n"
    "the main macro file.  Template text aside from the DEFINE macros is\n"
    "is ignored.";

    flag_code =
'    tTemplate* pT;
    procState = PROC_STATE_LIB_LOAD;
    pT = loadTemplate( pOptDesc->pzLastArg );
    unloadTemplate( pT );
    procState = PROC_STATE_OPTIONS;';
};

flag = {
    name      = base_name;
    value     = b;
    arg_type  = string;
    arg_name  = name;
    no_preset;
    descrip   = "Base name for output file(s)";
    doc =
    "A template may specify the exact name of the output file.\n"
    "Normally, it does not.  It is, instead, the base name of the\n"
    "definitions file, with suffixes removed.  If the definitions\n"
    "are being read from standard in or there is some other reason\n"
    "for using a different base file name, then use this option.";
};

flag = {
    name      = "definitions";
    arg_type  = string;
    arg_name  = file;
    no_preset;
    descrip   = "Definitions input file";
    disable   = no;
    enabled;
    doc =
    "Use this argument to specify the input definitions file with a\n"
    "command line option.  If you do not specify this option, then\n"
    "there must be a command line argument that specifies the file,\n"
    "even if only to specify stdin with a hyphen (@code{-}).\n"
    "Specify, @code{--no-definitions} when you wish to process\n"
    "a template without any active AutoGen definitions.\n";
};

flag = {
    name      = "load_scheme";
    value     = S;
    arg_type  = string;
    arg_name  = file;
    descrip   = "Scheme code file to load";
    settable;
    doc =
    "Use this argument to pre-load Scheme scripts into the Guile\n"
    "interpreter before template processing begins.\n"
    "Please note that the AutoGen specific functions are not loaded\n"
    "until after argument processing.  So, though they may be specified\n"
    "in lambda functions you define, they may not be invoked until after\n"
    "option processing is complete.\n";

    flag_code = '    int saveState = procState;
    char* pz;
    char  zPath[ MAXPATHLEN ];
    tSCC* apzSfx[] = { "scm", NULL };

    if (! SUCCESSFUL( findFile( pOptDesc->pzLastArg, zPath, apzSfx ))) {
        fprintf( stderr, "Cannot locate scheme file `%s\'\n",
                 pOptDesc->pzLastArg );
        USAGE( EXIT_FAILURE );
    }

    pz = asprintf( "(load \"%s\")", zPath );
    procState = PROC_STATE_GUILE_PRELOAD;
    gh_eval_str( pz );
    free( pz );
    procState = saveState;';
};

flag = {
    name       = skip_suffix;
    value      = s;
    arg_type   = string;
    arg_name   = suffix;
    no_preset;
    descrip    = "Omit the file with this suffix";
    max        = NOLIMIT;
    stack_arg;
    doc =
    "Occasionally, it may not be desirable to produce all of the output\n"
    "files specified in the template.  (For example, only the @file{.h}\n"
    "header file, but not the @file{.c} program text.)  To do this\n"
    "specify @code{--skip-suffix=c} on the command line.";
};

flag = {
    name       = source_time;
    descrip    = "set mod times to latest source";
    disable    = no;
    doc =
"If you stamp your output files with the `DNE' macro output, then your output
files will always be different, even if the content has not really changed.
If you use this option, then the modification time of the output files will
change only if the input files change.  This will help reduce unneeded builds.";

};

flag = {
    name        = equate;
    descrip     = "characters considered equivalent";
    arg_name    = char-list;
    arg_type    = string;
    arg_default = "_-^" /* default equivalence */;
    doc =
    "This option will alter the list of characters considered equivalent.\n"
    "The default are the three characters, \"_-^\".  (The latter is\n"
    "conventional on a Tandem, and I do a lot of work on the Tandem.)";
};

flag = {
    name        = doc_debug;
    documentation;
    descrip =
'The following options are often useful while debugging new templates:';
};

flag = {
    name        = loop_limit;
    arg_type    = number;
    arg_default = 256;
    arg_name    = lim;
    descrip     = "Limit on increment loops";
    doc =
    "This option prevents runaway loops.  For example, if you accidentally\n"
    "specify, \"FOR x (for-from 1) (for-to -1) (for-by 1)\",\n"
    "it will take a long time to finish.\n"
    "If you do have more than 256 entries in tables, you will\n"
    "need to specify a new limit with this option.";
};

flag = {
    name        = timeout;
    value       = t;
    arg_type    = number;
    arg_default = 10;
    arg_name    = time-lim;
    descrip     = "Time limit for servers";
    doc =
    "AutoGen works with a shell server process.  Most normal commands\n"
    "will complete in less than 10 seconds.  If, however, your commands\n"
    "need more time than this, use this option.";
};

flag = {
    name        = trace;
    arg_type    = keyword;
    arg_name    = level;
    descrip     = "tracing level of detail";
    keyword     = nothing, templates, block_macros, expressions, everything;

    doc =
    "This option will cause AutoGen to display a trace of its template\n"
    "processing.  There are five levels:\n"
    "@enumerate 0\n"
    "@item\nDoes no tracing at all (default)\n"
    "@item\n"
    "Traces the invocation of @code{DEFINE}d macros and @code{INCLUDE}s\n"
    "@item\nTraces all block macros.  The above, plus @code{IF}, @code{FOR},\n"
    "@code{CASE} and @code{WHILE}.\n"
    "@item\nDisplays the results of expression evaluations\n"
    "@item\n"
    "Displays the invocation of every AutoGen macro, even @code{TEXT}macros.\n"
    "@end enumerate";
};

flag = {
    name        = trace_out;
    arg_type    = string;
    arg_name    = file;
    descrip     = "tracing output file or filter";

    doc =
    "The output specified may be either a file name, or, if the option\n"
    "argument begins with the @code{pipe} operator (@code{|}),\n"
    "a command that will receive the tracing output as standard in.\n"
    "For example, @code{--traceout='| less'} will run the trace output\n"
    "through the @code{less} program.";

    flag_code =
'    if (*pOptDesc->pzLastArg == \'|\')
        pfTrace = popen( pOptDesc->pzLastArg + 1, "w" );
    else
        pfTrace = fopen( pOptDesc->pzLastArg, "w" );

    if (pfTrace == (FILE*)NULL) {
        fprintf( stderr, "Error %d (%s) opening `%s\' for output",
                 errno, strerror( errno ), pOptDesc->pzLastArg );
        exit( EXIT_FAILURE );
    }';
};

#ifdef DEBUG
/*
 *  These are for debugging AutoGen itself:
 */
flag = {
    name        = show_defs;
    no_preset;
    descrip     = "DEBUG: Show the definition tree";
    doc =
    "This option is only available with a DEBUG build of AutoGen.\n"
    "This will print out the complete definition tree before processing\n"
    "the template.";
};
flag = {
    name        = show_shell;
    no_preset;
    descrip     = "DEBUG: Show shell commands";
    doc =
    "This option is only available with a DEBUG build of AutoGen.\n"
    "This will cause @code{set -x} to be executed in the shell, with\n"
    "the resultant output printed to /dev/tty.";
};
export = "#undef DEBUG\n#define DEBUG 1";
#else
export = "#ifdef DEBUG\n"
         "#error DEBUG defined, but not defined for options\n"
         "#endif";
#endif

flag = {
    name        = doc_control;
    documentation;
    descrip =
'These options can be used to control what gets processed
in the definitions files and template files.';
};

flag = {
    name        = define;
    value       = D;
    arg_type    = string;
    arg_name    = value;
    max         = NOLIMIT;
    descrip     = "name to add to definition list";
    equivalence = define;
    stack_arg;
    settable;
    doc =
    "The AutoGen define names are used for the following purposes:\n\n"
    "@enumerate\n"
    "@item\n"
    "Sections of the AutoGen definitions may be enabled or disabled\n"
    "by using C-style #ifdef and #ifndef directives.\n"
    "@item\n"
    "When defining a value for a name, you may specify the index\n"
    "for a particular value.  That index may be a literal value,\n"
    "a define option or a value #define-d in the definitions themselves.\n"
    "@item\n"
    "The name of a file may be prefixed with @code{$NAME}.\n"
    "That part of the name string will be replaced with\n"
    "the define-d value for @code{NAME}.\n"
    "@item\n"
    "While processing a template, you may specify an index to retrieve\n"
    "a specific value.  That index may also be a define-d value.\n"
    "@end enumerate\n";
};

flag = {
    name        = undefine;
    value       = U;
    arg_type    = string;
    arg_name    = name-pat;
    max         = NOLIMIT;
    descrip     = "definition list removal pattern";
    equivalence = define;
    no_preset;
    stack_arg;
    settable;
    doc =
    "Just like 'C', AutoGen uses @code{#ifdef/#ifndef} preprocessing\n"
    "directives.  This option will cause the matching names to be\n"
    "removed from the list of defined values.";
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Program Documentation
 */

detail =
'AutoGen is a tool designed for generating program files
that contain repetitive text with varied substitutions.
See the info documentation for details.';

prog_man_descrip =
'\fBAutoGen\fP is a tool designed for generating program files that contain
repetitive text with varied substitutions.  Its goal is to simplify the
maintenance of programs that contain large amounts of repetitious text.
This is especially valuable if there are several blocks of such text
that must be kept synchronized.
.PP
One common example is the problem of maintaining the code required for
processing program options.  Processing options requires a minimum of
four different constructs be kept in proper order in different places in
your program.  You need at least: The flag character in the flag
string, code to process the flag when it is encountered, a global
state variable or two, and a line in the usage text.
You will need more things besides this if you choose to implement
long option names, rc/ini file processing, environment variables
and so on.

All of this can be done mechanically; with the proper templates and this
program.';

man_doc = '.SH "SEE ALSO"
This program is documented more fully in the
.IR AutoGen
Info system documentation.

.SH "EXAMPLES"
.ti +4
autogen -T man.tpl --base-name=autogen opts.def
.sp
This command produced this man page from the AutoGen
option definition file.  It overrides the template
specified in \fIopts.def\fP (normally \fIoptions.tpl\fP)
and uses \fIman.tpl\fP.  It also overrides the \fBbase-name\fP of
the output file, which is normally derived from the input
definition file name (viz. \fIopts\fP).';

/* end of opts.def */
