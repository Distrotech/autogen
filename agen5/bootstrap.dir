#! /bin/echo This_file_must_be_sourced,_not_executed
#
# ----------------------------------------------------------------------
# agen5/bootstrap.dir --- maintainer's bootstrap script
#
# Author:            Bruce Korb <bkorb@gnu.org>
# Time-stamp:        "2010-02-20 13:53:46 bkorb"
#            by: bkorb
##
##  This file is part of AutoGen.
##  AutoGen copyright (c) 1992-2009 by Bruce Korb - all rights reserved
##
## AutoGen is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by the
## Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## AutoGen is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
## See the GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License along
## with this program.  If not, see <http://www.gnu.org/licenses/>.
# ----------------------------------------------------------------------
# @(#) $Id$
# ----------------------------------------------------------------------

#  This script rebuilds sources not kept in the CVS repository.
#  These files are distributed, so it is not necessary to invoke
#  AutoGen before building AutoGen.  (Like I had to do long ago :)

#  "make" will invoke this file with the name of the desired output
#  as an argument.  We do this here rather than in the make file
#  because some of the rules are complex and we don't want to
#  deal with the dual update problem.

type die 2>/dev/null 1>&2 || {
    export mainpid=$$
    export progdir=$(dirname $0)
    progdir=$(cd ${progdir} > /dev/null ; pwd)
    PS4='>ag-bs> '

    die() {
        echo "build failure:  $*" >&2
        kill -9 ${mainpid}
        exit 1
    }
    case "${VERBOSE}" in
    ( [tTyY1]* ) VERBOSE=true ;;
    ( [fFnN0]* ) VERBOSE=false ;;
    ( * )
        case "$-" in
        ( *x* )  VERBOSE=true ;;
        (  *  )  VERBOSE=false ;;
        esac
    esac

    if ${VERBOSE}
    then setx=set\ -x dashx=-x
    else setx=:       dashx=
    fi
}

set_exe_var()
{
    d=$(cd $dir ; pwd)
    if [ -x $d/$prog ]
    then
      echo ${var}exe=$d/$prog export ${var}exe
    else
      eval f=\$${var}exe
      if test -x "$f"
      then
        echo ${var}exe=$f export ${var}exe
      else
        f=$(type $prog 2> /dev/null | \
            sed -e "s;^${prog} is [^/]*/;/;")
        case ${f} in
        ( */${prog} )  echo ${var}exe=${f} export ${var}exe ;;
        ( * )          echo unset ${var}exe ;;
        esac
      fi
    fi
}

set_defaults()
{
    local PS4=">${FUNCNAME}> "
    local f

    test "X${CDPATH}" = X || {
        ( unset CDPATH ) > /dev/null 2>&1 && unset CDPATH || CDPATH=''
    }

    trap 'die "trapped exit signal"' EXIT

    #  If the argument is "recursive", then we are bootstrapping.
    #  Otherwise, we are being invoked from "make".
    #
    case "${1}" in
    ( "" ) die "Specify what you want to bootstrap" ;;

    ( recursive )
        top_srcdir=$(cd .. ; pwd)
        top_builddir=${top_srcdir}
        builddir=$(pwd)
        srcdir=${srcdir}

        set -- $(egrep '##.*GEN-RULE' ${srcdir}/Makefile.am | \
            awk '{ print $2 }' ) functions.h
        arglist=""
        for f
        do test -f $f || arglist="$arglist $f"
        done
        ;;

    ( * )
        top_srcdir=${top_srcdir-$(cd .. ; pwd)}
        top_builddir=${top_builddir-$(dirname ${progdir})}
        builddir=$(pwd)
        srcdir=${srcdir-${builddir}}

        arglist=$(echo $*)

        AGexe=${AGexe-$(which autogen)}
        GDexe=${GDexe-$(which getdefs)}
        CLexe=${CLexe-$(which columns)}
        export AGexe GDexe CLexe
        ;;
    esac

    test -x "${AGexe}" || die "autogen is required"

    # Setup run_ag
    if ${VERBOSE}
    then
        run_ag()
        {
            local tfile=ag-${1}.log
            shift
            ${AGexe} --trace=every --trace-out=${tfile} "$@"
        }
    else
        run_ag()
        {
            shift
            echo ${AGexe} "$@"
            ${AGexe} "$@"
        }
    fi

    export runAG top_srcdir top_builddir builddir srcdir arglist

    #  Make sure we have a default for top build and source.
    #  Some of the templates need this information.
    #
    local verdata=$(egrep '^AG_' ${top_srcdir}/VERSION | \
       sed 's,^\(AG[^=]*\)\(.*\),\1\2 export \1,')
    eval "${verdata}"

    #  disable any $HOME defaults
    #
    HOME=/dev/null
    SHELL=/bin/sh

    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
    #
    # For the following to work, we must temporarily find or install
    # autogen, columns and getdefs from wherever they are found:
    #
    rmlist=

    #  Name our executable in one place and disable any $HOME defaults
    #  Use the local tools, if available.  Otherwise, look for them.
    #
    eval $(
        while read var prog dir
        do
            test -n ${#dir} && set_exe_var
        done ) <<- EOF
		AG  ${AGnam-autogen}  ${builddir}
		GD  ${GDnam-getdefs}  ${builddir}/../getdefs
		CL  ${CLnam-columns}  ${builddir}/../columns
		EOF

    ${VERBOSE:-false} && set -x || :
    #  Ensure complete success or a noticable failure
    #
    set -e
}

# # # # # # # # # # # # # # # # # # #
#
# Make the definition parser
#
make_defparse()
{
    local PS4=">${FUNCNAME}> "
    local opts=''

    test ${#DEBUG_ENABLED} -gt 0 && \
        opts=-DDEBUG_ENABLED

    run_ag defparse ${opts} defParse.def

    date > stamp-parse
}

# # # # # # # # # # # # # # # # # # #
#
# Make the option processing files:
#
make_opts()
{
    local PS4=">${FUNCNAME}> "
    test -z "${CLexe}" && die "Cannot locate columns"

    run_ag opts -L ${top_srcdir}/autoopts ${srcdir}/opts.def
    date > stamp-opts
}

# # # # # # # # # # # # # # # # # # #
#
# Make the pseudo-macro processing Finite State Machine
#
make_fsm()
{
    local PS4=">${FUNCNAME}> "

    run_ag pseudo pseudo.def
    run_ag cgi    cgi.def
    rm -f .fsm.*
    date > stamp-fsm
}

# # # # # # # # # # # # # # # # # # #
#
# Make the expression processing code
#
make_exprini()
{
    local PS4=">${FUNCNAME}> "
    test -z "${CLexe}" -o -z "${GDexe}" && \
        die "Cannot locate columns or getdefs"

    #  funcCase.c must be first file in list.
    #  It has the exparg attribute names.
    #
    exec 3> expr.cfg
    cat >&3 <<- _EOConfig_
	defs-to-get     gfunc
	template        snarf
	srcfile
	assign          two-phase = yes
	assign          group     = ag
	output          expr.def
	_EOConfig_

    test ${#DEBUG_ENABLED} -gt 0 && \
        printf '%-15s %s\n' assign 'debug-enabled = true' >&3

    for f in func*.c exp*.c
    do printf '%-15s %s\n' input ${f} ; done >&3
    exec 3>&-

    echo ${GDexe} load=expr.cfg
    set +e
    ( SHELL=sh ${GDexe} load=expr.cfg ${files} 2>&1 ) | \
      egrep -v 'no copies of pattern' >&2
    set -e
    rm -f expr.cfg
    run_ag expr expr.def
    test ${#DEBUGGING_AUTOGEN} -eq 0 -a "$t" != "expr.def" && \
        rm -f expr.def
    date > stamp-exprini
}

# # # # # # # # # # # # # # # # # # #
#
#  Make the directive.h header
#
make_directive()
{
    local PS4=">${FUNCNAME}> "
    test -z "${CLexe}" && die "Cannot locate columns"

    cat > directive.cfg <<- _EOConfig_
	defs-to-get    directive
	template       directive
	output         directive.def
	linenum
	_EOConfig_

    ${GDexe} load=directive.cfg ${srcdir}/defDirect.c
    run_ag directive -t30 directive.def
    rm -f directive.def directive.cfg
    date > stamp-directive
}

# # # # # # # # # # # # # # # # # # #
#
# Construct the texinfo doc
#
make_texi()
{
    local PS4=">${FUNCNAME}> "
    test -z "${CLexe}" && die "Cannot locate columns"

    eopt="-L${top_srcdir}/autoopts -Taginfo -DLEVEL=chapter -bautogen"
    run_ag texi ${eopt} ${srcdir}/opts.def
    date > stamp-texi
}

# # # # # # # # # # # # # # # # # # #
#
# Construct the man page
#
make_man()
{
    local PS4=">${FUNCNAME}> "
    test -z "${CLexe}" && die "Cannot locate columns"

    eopt="-L ${top_srcdir}/autoopts"
    run_ag opts ${eopt} -Tagman1 -bautogen ${srcdir}/opts.def

    ${GDexe} templ=agman3.tpl linenum output=fmemopen.def ${srcdir}/fmemopen.c
    run_ag fmemopen ${eopt} fmemopen.def
    rmlist=${rmlist}\ fmemopen.def

    date > stamp-man
}

# # # # # # # # # # # # # # # # # # #
#
#  Make the proto.h header & make sure the static proc declarations
#  are all current at the top of each module.
#
make_proto()
{
    local PS4=">${FUNCNAME}> "
    rm -f proto.h
    exec 5> proto.h

    local files=$(ls -1 *.c | grep -v 'fsm\.c$')
    local dirname=
    local marker=AUTOGEN_PROTO_H_GUARD
    local ct=0

    cat >&5 <<- _EOF_
	/* -*- buffer-read-only: t -*- vi: set ro:
	 *
	 * Prototypes for $(basename $(pwd))
	 * Generated $(date)
	 */
	#ifndef ${marker}
	#define ${marker} 1

	#ifndef LOCAL
	#  define LOCAL extern
	#  define REDEF_LOCAL 1
	#else
	#  undef  REDEF_LOCAL
	#endif
	_EOF_

    for f in ${files}
    do
        test ! -f ${f} && echo "not a file:  $f" >&2 && continue
        ct=$(echo $(egrep '(START|END)-STATIC-FORWARD' $f | wc -l) )

        case ${ct} in
        ( 2 )
            rm -f $f.[XY]

            exec 4> $f.X
            sed '/START-STATIC-FORWARD/q' $f >&4
            sed -n '/END-STATIC-FORWARD/,$p' $f > $f.Y
            sed -n '/^static /,/^{/p' $f.Y | \
                sed 's/^{.*//;s/)$/);/;$d' >&4
            cat $f.Y >&4
            exec 4>&-

            if cmp $f.X $f > /dev/null 2>&1
            then :
            else echo WARNING: ${f} has been updated >&2
                mv -f $f.X $f ; fi

            rm -f $f.[XY]
            ;;

        ( 0 ) : ;;
        ( * )
            echo "bad marker line count:" $ct in $f >&2
            continue
        esac

        ct=$(echo $(egrep '^LOCAL ' $f | wc -l) )
        test $ct -eq 0 && continue

        echo $'/*\n *  Extracted from '$f$'\n */' >&5
        sed -n '/^LOCAL /,/^{/p' $f | \
            sed 's/)$/);/;s/^{.*//' >&5
    done

    cat >&5 <<- _EOF_
	#ifdef REDEF_LOCAL
	#  undef LOCAL
	#  define LOCAL
	#endif
	#endif /* ${marker} */
	_EOF_
    exec 5>&-
}

make_functions()
{
    local PS4=">${FUNCNAME}> "
    test -z "${CLexe}" -o -z "${GDexe}" && \
        die "Cannot locate columns or getdefs"

    local files=$(grep -F -l '/*=macfunc' *.c)
    local opts='srcfile linenum defs=macfunc listattr=alias'

    ${GDexe} output=functions.def template=functions.tpl ${opts} ${files}
    run_ag functions functions.def
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
#  M A I N
#
set_defaults "$@"

#  FOR each output target,
#   DO the appropriate rule...
#
for t in ${arglist}
do
  echo Re-building "$t"
  case "$t" in
  ( stamp-parse     | \
    defParse-fsm.c  | \
    defParse-fsm.h  )           make_defparse ;;

  ( stamp-opts      | \
    opts.[ch]       )           make_opts ;;

  (stamp-fsm        )           make_fsm ;;

  ( stamp-exprini   | \
    expr.h          | \
    expr.def        | \
    expr.ini        )           make_exprini ;;

  ( stamp-directive | \
    directive.def   | \
    directive.h     )           make_directive ;;

  ( stamp-texi      | \
    autogen.texi    | \
    autogen.menu    )           make_texi ;;

  ( stamp-man       | \
    autogen.1       | \
    fmemopen.3      )           make_man ;;

  ( proto.h         )           make_proto ;;

  ( functions.h     )           make_functions ;;

  (*) die "Don't know how to make $t" ;;
  esac
done

#  IF we symlinked in columns or getdefs,
#  THEN it is time to unlink them
#
if [ ! -z "$rmlist" ]
then rm -f $rmlist ; fi

trap 'true' EXIT

# Local Variables:
# mode:shell-script
# sh-indentation:4
# sh-basic-offset:4
# indent-tabs-mode: nil
# End:

# bootstrap.dir ends here
