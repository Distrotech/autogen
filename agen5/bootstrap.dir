#! /bin/sh

#  This script rebuilds sources not kept in the CVS repository.
#  These files are distributed, so it is not necessary to invoke
#  AutoGen before building AutoGen.  (Like I had to do long ago :)

#  "make" will invoke this file with the name of the desired output
#  as an argument.  We do this here rather than in the make file
#  because some of the rules are complex and we don't want to
#  deal with the dual update problem.

#  Make sure we have a default for top build and source.
#  Some of the templates need this information.
#
if [ -z "$top_srcdir" ]
then
  top_builddir=..
  top_srcdir=..
  export top_builddir top_srcdir
fi

#  Name our executable in one place and disable any $HOME defaults
#
ag=AutoGen
HOME=/dev/null

#  Use the local ${ag}, if available.  Otherwise, look for it.
#
if [ ! -x ./${ag} ]
then
  AG=`$whence ${ag}`
  if [ -z "$AG" ]
  then
    echo "Cannot locate ${ag}.  Giving up"
    exit 1
  fi
else
    AG=./${ag}
fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
# For the following to work, we must temporarily install
# columns and getdefs from wherever they are found:
#
rmlist=

if type whence 2>&1 | grep 'not found' > /dev/null
then whence=which ; else whence=whence ; fi

#  The "getdefs" and "columns" programs are specifically
#  called out in some of the templates (ensuring that
#  they are the ones shipped with the current package)
#
GD=../getdefs/getdefs
if [ ! -x ${GD} ]
then
    ln -s `$whence getdefs` ${GD}
    rmlist="$rmlist ${GD}"
fi

COLS=../columns/columns
if [ ! -x ${COLS} ]
then
    ln -s `$whence columns` ${COLS}
    rmlist="$rmlist ${COLS}"
fi

# # # # # # # # # # # # # # # # # # # # # # #
#
#  Dump the bootstrap recursive argument.  We're not interested.
#
if [ "$1" = recursive ]
then
  shift
fi

#  IF we have no remaining argument, then do everything
#
if [ $# -eq 0 ]
then
  set defParse.c opts.c expr.ini functions.h directive.h \
	autogen.info autogen.1
fi

#  Ensure complete success or a noticable failure
#
set -e

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
#  FOR each output target,
#   DO the appropriate rule...
#
for t
do
  case "$t" in
  defParse.[ch] )
    #  Set a default for YACC
    #
    if [ -z "${YACC}" ]
    then
      YACC="byacc -d"
    fi

    echo ${YACC} defParse.y
    ${YACC} defParse.y
    rm -f defParse.c defParse.h
    if test -f y.out.c; then
      mv -f y.out.c defParse.c
      mv -f y.out.h defParse.h
    elif test -f y.tab.c; then
      mv -f y.tab.c defParse.c
      mv -f y.tab.h defParse.h
    elif test -f y_tab.c; then
      mv -f y_tab.c defParse.c
      mv -f y_tab.h defParse.h
    fi
    ;;

  opts.[ch] )
    # Make the option processing files:
    #
    echo ${AG} -L ../autoopts ${DEBUG_OPTS} opts.def
    ${AG} -L ../autoopts ${DEBUG_OPTS} opts.def
    date > stamp-opts
    ;;

  expr.ini )
    eopt="subblock=exparg=arg_name,arg_desc,arg_optional,arg_list"
    eopt="$eopt defs=gfunc templ=snarf srcfile"
    eopt="assign=group=ag $eopt autogen=${AG} base-name=expr"
    echo ${GD} $eopt exp*.c func*.c
    ( SHELL=ksh ${GD} $eopt exp*.c func*.c 2>&1 
    ) | egrep -v 'no copies of pattern'
    date > stamp-exprini
    ;;

  functions.h )
    eopt="template=functions defs=macfunc linenum srcfile filelist"
    eopt="$eopt autogen=${AG} base-name=functions"
    echo ${GD} $eopt func*.c
    ${GD} $eopt func*.c
    date > stamp-functions
    ;;

  directive.h )
    eopt="template=directive autogen=${AG} base-name=directive"
    echo ${GD} $eopt defDirect.c
    ${GD} $eopt defDirect.c
    date > stamp-directive
    ;;

  autogen.info | autogen.menu )
    # Construct the info doc
    #
    eopt="-L${top_srcdir}/autoopts -Taginfo -DLEVEL=chapter ${DEBUG_OPTS}"
    echo ${AG} ${eopt} -bautogen opts.def
    ${AG} ${eopt} -bautogen opts.def
    ;;

  autogen.1 )
    # Construct the man page
    #
    eopt="-L ${top_srcdir}/autoopts -Tagman1 -bautogen"
    echo ${AG} ${eopt} ./opts.def
    ${AG} ${eopt} ./opts.def
    ;;
  esac
done

#  IF we symlinked in columns or getdefs,
#  THEN it is time to unlink them
#
if [ ! -z "$rmlist" ]
then rm -f $rmlist ; fi
